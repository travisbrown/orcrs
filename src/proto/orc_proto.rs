// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `orc_proto.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct IntegerStatistics {
    // message fields
    minimum: ::std::option::Option<i64>,
    maximum: ::std::option::Option<i64>,
    sum: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IntegerStatistics {
    fn default() -> &'a IntegerStatistics {
        <IntegerStatistics as ::protobuf::Message>::default_instance()
    }
}

impl IntegerStatistics {
    pub fn new() -> IntegerStatistics {
        ::std::default::Default::default()
    }

    // optional sint64 minimum = 1;


    pub fn get_minimum(&self) -> i64 {
        self.minimum.unwrap_or(0)
    }
    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: i64) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // optional sint64 maximum = 2;


    pub fn get_maximum(&self) -> i64 {
        self.maximum.unwrap_or(0)
    }
    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: i64) {
        self.maximum = ::std::option::Option::Some(v);
    }

    // optional sint64 sum = 3;


    pub fn get_sum(&self) -> i64 {
        self.sum.unwrap_or(0)
    }
    pub fn clear_sum(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: i64) {
        self.sum = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for IntegerStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.minimum = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.maximum = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.sum = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.minimum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        if let Some(v) = self.maximum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        if let Some(v) = self.sum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.minimum {
            os.write_sint64(1, v)?;
        }
        if let Some(v) = self.maximum {
            os.write_sint64(2, v)?;
        }
        if let Some(v) = self.sum {
            os.write_sint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IntegerStatistics {
        IntegerStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "minimum",
                |m: &IntegerStatistics| { &m.minimum },
                |m: &mut IntegerStatistics| { &mut m.minimum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "maximum",
                |m: &IntegerStatistics| { &m.maximum },
                |m: &mut IntegerStatistics| { &mut m.maximum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "sum",
                |m: &IntegerStatistics| { &m.sum },
                |m: &mut IntegerStatistics| { &mut m.sum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IntegerStatistics>(
                "IntegerStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IntegerStatistics {
        static instance: ::protobuf::rt::LazyV2<IntegerStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IntegerStatistics::new)
    }
}

impl ::protobuf::Clear for IntegerStatistics {
    fn clear(&mut self) {
        self.minimum = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IntegerStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntegerStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DoubleStatistics {
    // message fields
    minimum: ::std::option::Option<f64>,
    maximum: ::std::option::Option<f64>,
    sum: ::std::option::Option<f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DoubleStatistics {
    fn default() -> &'a DoubleStatistics {
        <DoubleStatistics as ::protobuf::Message>::default_instance()
    }
}

impl DoubleStatistics {
    pub fn new() -> DoubleStatistics {
        ::std::default::Default::default()
    }

    // optional double minimum = 1;


    pub fn get_minimum(&self) -> f64 {
        self.minimum.unwrap_or(0.)
    }
    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: f64) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // optional double maximum = 2;


    pub fn get_maximum(&self) -> f64 {
        self.maximum.unwrap_or(0.)
    }
    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: f64) {
        self.maximum = ::std::option::Option::Some(v);
    }

    // optional double sum = 3;


    pub fn get_sum(&self) -> f64 {
        self.sum.unwrap_or(0.)
    }
    pub fn clear_sum(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: f64) {
        self.sum = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DoubleStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.minimum = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.maximum = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.sum = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.minimum {
            my_size += 9;
        }
        if let Some(v) = self.maximum {
            my_size += 9;
        }
        if let Some(v) = self.sum {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.minimum {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.maximum {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.sum {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DoubleStatistics {
        DoubleStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "minimum",
                |m: &DoubleStatistics| { &m.minimum },
                |m: &mut DoubleStatistics| { &mut m.minimum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "maximum",
                |m: &DoubleStatistics| { &m.maximum },
                |m: &mut DoubleStatistics| { &mut m.maximum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "sum",
                |m: &DoubleStatistics| { &m.sum },
                |m: &mut DoubleStatistics| { &mut m.sum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DoubleStatistics>(
                "DoubleStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DoubleStatistics {
        static instance: ::protobuf::rt::LazyV2<DoubleStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DoubleStatistics::new)
    }
}

impl ::protobuf::Clear for DoubleStatistics {
    fn clear(&mut self) {
        self.minimum = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DoubleStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoubleStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringStatistics {
    // message fields
    minimum: ::protobuf::SingularField<::std::string::String>,
    maximum: ::protobuf::SingularField<::std::string::String>,
    sum: ::std::option::Option<i64>,
    lowerBound: ::protobuf::SingularField<::std::string::String>,
    upperBound: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringStatistics {
    fn default() -> &'a StringStatistics {
        <StringStatistics as ::protobuf::Message>::default_instance()
    }
}

impl StringStatistics {
    pub fn new() -> StringStatistics {
        ::std::default::Default::default()
    }

    // optional string minimum = 1;


    pub fn get_minimum(&self) -> &str {
        match self.minimum.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_minimum(&mut self) {
        self.minimum.clear();
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: ::std::string::String) {
        self.minimum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minimum(&mut self) -> &mut ::std::string::String {
        if self.minimum.is_none() {
            self.minimum.set_default();
        }
        self.minimum.as_mut().unwrap()
    }

    // Take field
    pub fn take_minimum(&mut self) -> ::std::string::String {
        self.minimum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string maximum = 2;


    pub fn get_maximum(&self) -> &str {
        match self.maximum.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_maximum(&mut self) {
        self.maximum.clear();
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: ::std::string::String) {
        self.maximum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maximum(&mut self) -> &mut ::std::string::String {
        if self.maximum.is_none() {
            self.maximum.set_default();
        }
        self.maximum.as_mut().unwrap()
    }

    // Take field
    pub fn take_maximum(&mut self) -> ::std::string::String {
        self.maximum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint64 sum = 3;


    pub fn get_sum(&self) -> i64 {
        self.sum.unwrap_or(0)
    }
    pub fn clear_sum(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: i64) {
        self.sum = ::std::option::Option::Some(v);
    }

    // optional string lowerBound = 4;


    pub fn get_lowerBound(&self) -> &str {
        match self.lowerBound.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_lowerBound(&mut self) {
        self.lowerBound.clear();
    }

    pub fn has_lowerBound(&self) -> bool {
        self.lowerBound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lowerBound(&mut self, v: ::std::string::String) {
        self.lowerBound = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lowerBound(&mut self) -> &mut ::std::string::String {
        if self.lowerBound.is_none() {
            self.lowerBound.set_default();
        }
        self.lowerBound.as_mut().unwrap()
    }

    // Take field
    pub fn take_lowerBound(&mut self) -> ::std::string::String {
        self.lowerBound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string upperBound = 5;


    pub fn get_upperBound(&self) -> &str {
        match self.upperBound.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_upperBound(&mut self) {
        self.upperBound.clear();
    }

    pub fn has_upperBound(&self) -> bool {
        self.upperBound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upperBound(&mut self, v: ::std::string::String) {
        self.upperBound = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upperBound(&mut self) -> &mut ::std::string::String {
        if self.upperBound.is_none() {
            self.upperBound.set_default();
        }
        self.upperBound.as_mut().unwrap()
    }

    // Take field
    pub fn take_upperBound(&mut self) -> ::std::string::String {
        self.upperBound.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for StringStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.minimum)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.maximum)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.sum = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lowerBound)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.upperBound)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.minimum.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.maximum.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.sum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(ref v) = self.lowerBound.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.upperBound.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.minimum.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.maximum.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.sum {
            os.write_sint64(3, v)?;
        }
        if let Some(ref v) = self.lowerBound.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.upperBound.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringStatistics {
        StringStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "minimum",
                |m: &StringStatistics| { &m.minimum },
                |m: &mut StringStatistics| { &mut m.minimum },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "maximum",
                |m: &StringStatistics| { &m.maximum },
                |m: &mut StringStatistics| { &mut m.maximum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "sum",
                |m: &StringStatistics| { &m.sum },
                |m: &mut StringStatistics| { &mut m.sum },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lowerBound",
                |m: &StringStatistics| { &m.lowerBound },
                |m: &mut StringStatistics| { &mut m.lowerBound },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "upperBound",
                |m: &StringStatistics| { &m.upperBound },
                |m: &mut StringStatistics| { &mut m.upperBound },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringStatistics>(
                "StringStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringStatistics {
        static instance: ::protobuf::rt::LazyV2<StringStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringStatistics::new)
    }
}

impl ::protobuf::Clear for StringStatistics {
    fn clear(&mut self) {
        self.minimum.clear();
        self.maximum.clear();
        self.sum = ::std::option::Option::None;
        self.lowerBound.clear();
        self.upperBound.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BucketStatistics {
    // message fields
    pub count: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BucketStatistics {
    fn default() -> &'a BucketStatistics {
        <BucketStatistics as ::protobuf::Message>::default_instance()
    }
}

impl BucketStatistics {
    pub fn new() -> BucketStatistics {
        ::std::default::Default::default()
    }

    // repeated uint64 count = 1;


    pub fn get_count(&self) -> &[u64] {
        &self.count
    }
    pub fn clear_count(&mut self) {
        self.count.clear();
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: ::std::vec::Vec<u64>) {
        self.count = v;
    }

    // Mutable pointer to the field.
    pub fn mut_count(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.count
    }

    // Take field
    pub fn take_count(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.count, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BucketStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.count)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.count.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(1, &self.count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.count.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.count))?;
            for v in &self.count {
                os.write_uint64_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BucketStatistics {
        BucketStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "count",
                |m: &BucketStatistics| { &m.count },
                |m: &mut BucketStatistics| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BucketStatistics>(
                "BucketStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BucketStatistics {
        static instance: ::protobuf::rt::LazyV2<BucketStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BucketStatistics::new)
    }
}

impl ::protobuf::Clear for BucketStatistics {
    fn clear(&mut self) {
        self.count.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BucketStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BucketStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecimalStatistics {
    // message fields
    minimum: ::protobuf::SingularField<::std::string::String>,
    maximum: ::protobuf::SingularField<::std::string::String>,
    sum: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecimalStatistics {
    fn default() -> &'a DecimalStatistics {
        <DecimalStatistics as ::protobuf::Message>::default_instance()
    }
}

impl DecimalStatistics {
    pub fn new() -> DecimalStatistics {
        ::std::default::Default::default()
    }

    // optional string minimum = 1;


    pub fn get_minimum(&self) -> &str {
        match self.minimum.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_minimum(&mut self) {
        self.minimum.clear();
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: ::std::string::String) {
        self.minimum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minimum(&mut self) -> &mut ::std::string::String {
        if self.minimum.is_none() {
            self.minimum.set_default();
        }
        self.minimum.as_mut().unwrap()
    }

    // Take field
    pub fn take_minimum(&mut self) -> ::std::string::String {
        self.minimum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string maximum = 2;


    pub fn get_maximum(&self) -> &str {
        match self.maximum.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_maximum(&mut self) {
        self.maximum.clear();
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: ::std::string::String) {
        self.maximum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maximum(&mut self) -> &mut ::std::string::String {
        if self.maximum.is_none() {
            self.maximum.set_default();
        }
        self.maximum.as_mut().unwrap()
    }

    // Take field
    pub fn take_maximum(&mut self) -> ::std::string::String {
        self.maximum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sum = 3;


    pub fn get_sum(&self) -> &str {
        match self.sum.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sum(&mut self) {
        self.sum.clear();
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: ::std::string::String) {
        self.sum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sum(&mut self) -> &mut ::std::string::String {
        if self.sum.is_none() {
            self.sum.set_default();
        }
        self.sum.as_mut().unwrap()
    }

    // Take field
    pub fn take_sum(&mut self) -> ::std::string::String {
        self.sum.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DecimalStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.minimum)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.maximum)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sum)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.minimum.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.maximum.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.sum.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.minimum.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.maximum.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.sum.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecimalStatistics {
        DecimalStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "minimum",
                |m: &DecimalStatistics| { &m.minimum },
                |m: &mut DecimalStatistics| { &mut m.minimum },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "maximum",
                |m: &DecimalStatistics| { &m.maximum },
                |m: &mut DecimalStatistics| { &mut m.maximum },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sum",
                |m: &DecimalStatistics| { &m.sum },
                |m: &mut DecimalStatistics| { &mut m.sum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecimalStatistics>(
                "DecimalStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecimalStatistics {
        static instance: ::protobuf::rt::LazyV2<DecimalStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecimalStatistics::new)
    }
}

impl ::protobuf::Clear for DecimalStatistics {
    fn clear(&mut self) {
        self.minimum.clear();
        self.maximum.clear();
        self.sum.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecimalStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecimalStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DateStatistics {
    // message fields
    minimum: ::std::option::Option<i32>,
    maximum: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DateStatistics {
    fn default() -> &'a DateStatistics {
        <DateStatistics as ::protobuf::Message>::default_instance()
    }
}

impl DateStatistics {
    pub fn new() -> DateStatistics {
        ::std::default::Default::default()
    }

    // optional sint32 minimum = 1;


    pub fn get_minimum(&self) -> i32 {
        self.minimum.unwrap_or(0)
    }
    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: i32) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // optional sint32 maximum = 2;


    pub fn get_maximum(&self) -> i32 {
        self.maximum.unwrap_or(0)
    }
    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: i32) {
        self.maximum = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DateStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.minimum = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.maximum = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.minimum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        if let Some(v) = self.maximum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.minimum {
            os.write_sint32(1, v)?;
        }
        if let Some(v) = self.maximum {
            os.write_sint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DateStatistics {
        DateStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "minimum",
                |m: &DateStatistics| { &m.minimum },
                |m: &mut DateStatistics| { &mut m.minimum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "maximum",
                |m: &DateStatistics| { &m.maximum },
                |m: &mut DateStatistics| { &mut m.maximum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DateStatistics>(
                "DateStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DateStatistics {
        static instance: ::protobuf::rt::LazyV2<DateStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DateStatistics::new)
    }
}

impl ::protobuf::Clear for DateStatistics {
    fn clear(&mut self) {
        self.minimum = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DateStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DateStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimestampStatistics {
    // message fields
    minimum: ::std::option::Option<i64>,
    maximum: ::std::option::Option<i64>,
    minimumUtc: ::std::option::Option<i64>,
    maximumUtc: ::std::option::Option<i64>,
    minimumNanos: ::std::option::Option<i32>,
    maximumNanos: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimestampStatistics {
    fn default() -> &'a TimestampStatistics {
        <TimestampStatistics as ::protobuf::Message>::default_instance()
    }
}

impl TimestampStatistics {
    pub fn new() -> TimestampStatistics {
        ::std::default::Default::default()
    }

    // optional sint64 minimum = 1;


    pub fn get_minimum(&self) -> i64 {
        self.minimum.unwrap_or(0)
    }
    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: i64) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // optional sint64 maximum = 2;


    pub fn get_maximum(&self) -> i64 {
        self.maximum.unwrap_or(0)
    }
    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: i64) {
        self.maximum = ::std::option::Option::Some(v);
    }

    // optional sint64 minimumUtc = 3;


    pub fn get_minimumUtc(&self) -> i64 {
        self.minimumUtc.unwrap_or(0)
    }
    pub fn clear_minimumUtc(&mut self) {
        self.minimumUtc = ::std::option::Option::None;
    }

    pub fn has_minimumUtc(&self) -> bool {
        self.minimumUtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimumUtc(&mut self, v: i64) {
        self.minimumUtc = ::std::option::Option::Some(v);
    }

    // optional sint64 maximumUtc = 4;


    pub fn get_maximumUtc(&self) -> i64 {
        self.maximumUtc.unwrap_or(0)
    }
    pub fn clear_maximumUtc(&mut self) {
        self.maximumUtc = ::std::option::Option::None;
    }

    pub fn has_maximumUtc(&self) -> bool {
        self.maximumUtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximumUtc(&mut self, v: i64) {
        self.maximumUtc = ::std::option::Option::Some(v);
    }

    // optional int32 minimumNanos = 5;


    pub fn get_minimumNanos(&self) -> i32 {
        self.minimumNanos.unwrap_or(0)
    }
    pub fn clear_minimumNanos(&mut self) {
        self.minimumNanos = ::std::option::Option::None;
    }

    pub fn has_minimumNanos(&self) -> bool {
        self.minimumNanos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimumNanos(&mut self, v: i32) {
        self.minimumNanos = ::std::option::Option::Some(v);
    }

    // optional int32 maximumNanos = 6;


    pub fn get_maximumNanos(&self) -> i32 {
        self.maximumNanos.unwrap_or(0)
    }
    pub fn clear_maximumNanos(&mut self) {
        self.maximumNanos = ::std::option::Option::None;
    }

    pub fn has_maximumNanos(&self) -> bool {
        self.maximumNanos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximumNanos(&mut self, v: i32) {
        self.maximumNanos = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TimestampStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.minimum = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.maximum = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.minimumUtc = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.maximumUtc = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.minimumNanos = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maximumNanos = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.minimum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        if let Some(v) = self.maximum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        if let Some(v) = self.minimumUtc {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(v) = self.maximumUtc {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, v);
        }
        if let Some(v) = self.minimumNanos {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximumNanos {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.minimum {
            os.write_sint64(1, v)?;
        }
        if let Some(v) = self.maximum {
            os.write_sint64(2, v)?;
        }
        if let Some(v) = self.minimumUtc {
            os.write_sint64(3, v)?;
        }
        if let Some(v) = self.maximumUtc {
            os.write_sint64(4, v)?;
        }
        if let Some(v) = self.minimumNanos {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.maximumNanos {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimestampStatistics {
        TimestampStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "minimum",
                |m: &TimestampStatistics| { &m.minimum },
                |m: &mut TimestampStatistics| { &mut m.minimum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "maximum",
                |m: &TimestampStatistics| { &m.maximum },
                |m: &mut TimestampStatistics| { &mut m.maximum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "minimumUtc",
                |m: &TimestampStatistics| { &m.minimumUtc },
                |m: &mut TimestampStatistics| { &mut m.minimumUtc },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "maximumUtc",
                |m: &TimestampStatistics| { &m.maximumUtc },
                |m: &mut TimestampStatistics| { &mut m.maximumUtc },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "minimumNanos",
                |m: &TimestampStatistics| { &m.minimumNanos },
                |m: &mut TimestampStatistics| { &mut m.minimumNanos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maximumNanos",
                |m: &TimestampStatistics| { &m.maximumNanos },
                |m: &mut TimestampStatistics| { &mut m.maximumNanos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimestampStatistics>(
                "TimestampStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimestampStatistics {
        static instance: ::protobuf::rt::LazyV2<TimestampStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimestampStatistics::new)
    }
}

impl ::protobuf::Clear for TimestampStatistics {
    fn clear(&mut self) {
        self.minimum = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.minimumUtc = ::std::option::Option::None;
        self.maximumUtc = ::std::option::Option::None;
        self.minimumNanos = ::std::option::Option::None;
        self.maximumNanos = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimestampStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimestampStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BinaryStatistics {
    // message fields
    sum: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BinaryStatistics {
    fn default() -> &'a BinaryStatistics {
        <BinaryStatistics as ::protobuf::Message>::default_instance()
    }
}

impl BinaryStatistics {
    pub fn new() -> BinaryStatistics {
        ::std::default::Default::default()
    }

    // optional sint64 sum = 1;


    pub fn get_sum(&self) -> i64 {
        self.sum.unwrap_or(0)
    }
    pub fn clear_sum(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: i64) {
        self.sum = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BinaryStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.sum = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sum {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sum {
            os.write_sint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinaryStatistics {
        BinaryStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "sum",
                |m: &BinaryStatistics| { &m.sum },
                |m: &mut BinaryStatistics| { &mut m.sum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BinaryStatistics>(
                "BinaryStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BinaryStatistics {
        static instance: ::protobuf::rt::LazyV2<BinaryStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BinaryStatistics::new)
    }
}

impl ::protobuf::Clear for BinaryStatistics {
    fn clear(&mut self) {
        self.sum = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BinaryStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CollectionStatistics {
    // message fields
    minChildren: ::std::option::Option<u64>,
    maxChildren: ::std::option::Option<u64>,
    totalChildren: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CollectionStatistics {
    fn default() -> &'a CollectionStatistics {
        <CollectionStatistics as ::protobuf::Message>::default_instance()
    }
}

impl CollectionStatistics {
    pub fn new() -> CollectionStatistics {
        ::std::default::Default::default()
    }

    // optional uint64 minChildren = 1;


    pub fn get_minChildren(&self) -> u64 {
        self.minChildren.unwrap_or(0)
    }
    pub fn clear_minChildren(&mut self) {
        self.minChildren = ::std::option::Option::None;
    }

    pub fn has_minChildren(&self) -> bool {
        self.minChildren.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minChildren(&mut self, v: u64) {
        self.minChildren = ::std::option::Option::Some(v);
    }

    // optional uint64 maxChildren = 2;


    pub fn get_maxChildren(&self) -> u64 {
        self.maxChildren.unwrap_or(0)
    }
    pub fn clear_maxChildren(&mut self) {
        self.maxChildren = ::std::option::Option::None;
    }

    pub fn has_maxChildren(&self) -> bool {
        self.maxChildren.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxChildren(&mut self, v: u64) {
        self.maxChildren = ::std::option::Option::Some(v);
    }

    // optional uint64 totalChildren = 3;


    pub fn get_totalChildren(&self) -> u64 {
        self.totalChildren.unwrap_or(0)
    }
    pub fn clear_totalChildren(&mut self) {
        self.totalChildren = ::std::option::Option::None;
    }

    pub fn has_totalChildren(&self) -> bool {
        self.totalChildren.is_some()
    }

    // Param is passed by value, moved
    pub fn set_totalChildren(&mut self, v: u64) {
        self.totalChildren = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CollectionStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minChildren = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.maxChildren = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.totalChildren = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.minChildren {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxChildren {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.totalChildren {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.minChildren {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.maxChildren {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.totalChildren {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CollectionStatistics {
        CollectionStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "minChildren",
                |m: &CollectionStatistics| { &m.minChildren },
                |m: &mut CollectionStatistics| { &mut m.minChildren },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "maxChildren",
                |m: &CollectionStatistics| { &m.maxChildren },
                |m: &mut CollectionStatistics| { &mut m.maxChildren },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "totalChildren",
                |m: &CollectionStatistics| { &m.totalChildren },
                |m: &mut CollectionStatistics| { &mut m.totalChildren },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CollectionStatistics>(
                "CollectionStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CollectionStatistics {
        static instance: ::protobuf::rt::LazyV2<CollectionStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CollectionStatistics::new)
    }
}

impl ::protobuf::Clear for CollectionStatistics {
    fn clear(&mut self) {
        self.minChildren = ::std::option::Option::None;
        self.maxChildren = ::std::option::Option::None;
        self.totalChildren = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CollectionStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectionStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ColumnStatistics {
    // message fields
    numberOfValues: ::std::option::Option<u64>,
    pub intStatistics: ::protobuf::SingularPtrField<IntegerStatistics>,
    pub doubleStatistics: ::protobuf::SingularPtrField<DoubleStatistics>,
    pub stringStatistics: ::protobuf::SingularPtrField<StringStatistics>,
    pub bucketStatistics: ::protobuf::SingularPtrField<BucketStatistics>,
    pub decimalStatistics: ::protobuf::SingularPtrField<DecimalStatistics>,
    pub dateStatistics: ::protobuf::SingularPtrField<DateStatistics>,
    pub binaryStatistics: ::protobuf::SingularPtrField<BinaryStatistics>,
    pub timestampStatistics: ::protobuf::SingularPtrField<TimestampStatistics>,
    hasNull: ::std::option::Option<bool>,
    bytesOnDisk: ::std::option::Option<u64>,
    pub collectionStatistics: ::protobuf::SingularPtrField<CollectionStatistics>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColumnStatistics {
    fn default() -> &'a ColumnStatistics {
        <ColumnStatistics as ::protobuf::Message>::default_instance()
    }
}

impl ColumnStatistics {
    pub fn new() -> ColumnStatistics {
        ::std::default::Default::default()
    }

    // optional uint64 numberOfValues = 1;


    pub fn get_numberOfValues(&self) -> u64 {
        self.numberOfValues.unwrap_or(0)
    }
    pub fn clear_numberOfValues(&mut self) {
        self.numberOfValues = ::std::option::Option::None;
    }

    pub fn has_numberOfValues(&self) -> bool {
        self.numberOfValues.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberOfValues(&mut self, v: u64) {
        self.numberOfValues = ::std::option::Option::Some(v);
    }

    // optional .orc.proto.IntegerStatistics intStatistics = 2;


    pub fn get_intStatistics(&self) -> &IntegerStatistics {
        self.intStatistics.as_ref().unwrap_or_else(|| <IntegerStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_intStatistics(&mut self) {
        self.intStatistics.clear();
    }

    pub fn has_intStatistics(&self) -> bool {
        self.intStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_intStatistics(&mut self, v: IntegerStatistics) {
        self.intStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_intStatistics(&mut self) -> &mut IntegerStatistics {
        if self.intStatistics.is_none() {
            self.intStatistics.set_default();
        }
        self.intStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_intStatistics(&mut self) -> IntegerStatistics {
        self.intStatistics.take().unwrap_or_else(|| IntegerStatistics::new())
    }

    // optional .orc.proto.DoubleStatistics doubleStatistics = 3;


    pub fn get_doubleStatistics(&self) -> &DoubleStatistics {
        self.doubleStatistics.as_ref().unwrap_or_else(|| <DoubleStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_doubleStatistics(&mut self) {
        self.doubleStatistics.clear();
    }

    pub fn has_doubleStatistics(&self) -> bool {
        self.doubleStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doubleStatistics(&mut self, v: DoubleStatistics) {
        self.doubleStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doubleStatistics(&mut self) -> &mut DoubleStatistics {
        if self.doubleStatistics.is_none() {
            self.doubleStatistics.set_default();
        }
        self.doubleStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_doubleStatistics(&mut self) -> DoubleStatistics {
        self.doubleStatistics.take().unwrap_or_else(|| DoubleStatistics::new())
    }

    // optional .orc.proto.StringStatistics stringStatistics = 4;


    pub fn get_stringStatistics(&self) -> &StringStatistics {
        self.stringStatistics.as_ref().unwrap_or_else(|| <StringStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stringStatistics(&mut self) {
        self.stringStatistics.clear();
    }

    pub fn has_stringStatistics(&self) -> bool {
        self.stringStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stringStatistics(&mut self, v: StringStatistics) {
        self.stringStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stringStatistics(&mut self) -> &mut StringStatistics {
        if self.stringStatistics.is_none() {
            self.stringStatistics.set_default();
        }
        self.stringStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_stringStatistics(&mut self) -> StringStatistics {
        self.stringStatistics.take().unwrap_or_else(|| StringStatistics::new())
    }

    // optional .orc.proto.BucketStatistics bucketStatistics = 5;


    pub fn get_bucketStatistics(&self) -> &BucketStatistics {
        self.bucketStatistics.as_ref().unwrap_or_else(|| <BucketStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bucketStatistics(&mut self) {
        self.bucketStatistics.clear();
    }

    pub fn has_bucketStatistics(&self) -> bool {
        self.bucketStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bucketStatistics(&mut self, v: BucketStatistics) {
        self.bucketStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucketStatistics(&mut self) -> &mut BucketStatistics {
        if self.bucketStatistics.is_none() {
            self.bucketStatistics.set_default();
        }
        self.bucketStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_bucketStatistics(&mut self) -> BucketStatistics {
        self.bucketStatistics.take().unwrap_or_else(|| BucketStatistics::new())
    }

    // optional .orc.proto.DecimalStatistics decimalStatistics = 6;


    pub fn get_decimalStatistics(&self) -> &DecimalStatistics {
        self.decimalStatistics.as_ref().unwrap_or_else(|| <DecimalStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_decimalStatistics(&mut self) {
        self.decimalStatistics.clear();
    }

    pub fn has_decimalStatistics(&self) -> bool {
        self.decimalStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decimalStatistics(&mut self, v: DecimalStatistics) {
        self.decimalStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decimalStatistics(&mut self) -> &mut DecimalStatistics {
        if self.decimalStatistics.is_none() {
            self.decimalStatistics.set_default();
        }
        self.decimalStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_decimalStatistics(&mut self) -> DecimalStatistics {
        self.decimalStatistics.take().unwrap_or_else(|| DecimalStatistics::new())
    }

    // optional .orc.proto.DateStatistics dateStatistics = 7;


    pub fn get_dateStatistics(&self) -> &DateStatistics {
        self.dateStatistics.as_ref().unwrap_or_else(|| <DateStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dateStatistics(&mut self) {
        self.dateStatistics.clear();
    }

    pub fn has_dateStatistics(&self) -> bool {
        self.dateStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dateStatistics(&mut self, v: DateStatistics) {
        self.dateStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dateStatistics(&mut self) -> &mut DateStatistics {
        if self.dateStatistics.is_none() {
            self.dateStatistics.set_default();
        }
        self.dateStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_dateStatistics(&mut self) -> DateStatistics {
        self.dateStatistics.take().unwrap_or_else(|| DateStatistics::new())
    }

    // optional .orc.proto.BinaryStatistics binaryStatistics = 8;


    pub fn get_binaryStatistics(&self) -> &BinaryStatistics {
        self.binaryStatistics.as_ref().unwrap_or_else(|| <BinaryStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_binaryStatistics(&mut self) {
        self.binaryStatistics.clear();
    }

    pub fn has_binaryStatistics(&self) -> bool {
        self.binaryStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_binaryStatistics(&mut self, v: BinaryStatistics) {
        self.binaryStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_binaryStatistics(&mut self) -> &mut BinaryStatistics {
        if self.binaryStatistics.is_none() {
            self.binaryStatistics.set_default();
        }
        self.binaryStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_binaryStatistics(&mut self) -> BinaryStatistics {
        self.binaryStatistics.take().unwrap_or_else(|| BinaryStatistics::new())
    }

    // optional .orc.proto.TimestampStatistics timestampStatistics = 9;


    pub fn get_timestampStatistics(&self) -> &TimestampStatistics {
        self.timestampStatistics.as_ref().unwrap_or_else(|| <TimestampStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_timestampStatistics(&mut self) {
        self.timestampStatistics.clear();
    }

    pub fn has_timestampStatistics(&self) -> bool {
        self.timestampStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestampStatistics(&mut self, v: TimestampStatistics) {
        self.timestampStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestampStatistics(&mut self) -> &mut TimestampStatistics {
        if self.timestampStatistics.is_none() {
            self.timestampStatistics.set_default();
        }
        self.timestampStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_timestampStatistics(&mut self) -> TimestampStatistics {
        self.timestampStatistics.take().unwrap_or_else(|| TimestampStatistics::new())
    }

    // optional bool hasNull = 10;


    pub fn get_hasNull(&self) -> bool {
        self.hasNull.unwrap_or(false)
    }
    pub fn clear_hasNull(&mut self) {
        self.hasNull = ::std::option::Option::None;
    }

    pub fn has_hasNull(&self) -> bool {
        self.hasNull.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasNull(&mut self, v: bool) {
        self.hasNull = ::std::option::Option::Some(v);
    }

    // optional uint64 bytesOnDisk = 11;


    pub fn get_bytesOnDisk(&self) -> u64 {
        self.bytesOnDisk.unwrap_or(0)
    }
    pub fn clear_bytesOnDisk(&mut self) {
        self.bytesOnDisk = ::std::option::Option::None;
    }

    pub fn has_bytesOnDisk(&self) -> bool {
        self.bytesOnDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesOnDisk(&mut self, v: u64) {
        self.bytesOnDisk = ::std::option::Option::Some(v);
    }

    // optional .orc.proto.CollectionStatistics collectionStatistics = 12;


    pub fn get_collectionStatistics(&self) -> &CollectionStatistics {
        self.collectionStatistics.as_ref().unwrap_or_else(|| <CollectionStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_collectionStatistics(&mut self) {
        self.collectionStatistics.clear();
    }

    pub fn has_collectionStatistics(&self) -> bool {
        self.collectionStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collectionStatistics(&mut self, v: CollectionStatistics) {
        self.collectionStatistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collectionStatistics(&mut self) -> &mut CollectionStatistics {
        if self.collectionStatistics.is_none() {
            self.collectionStatistics.set_default();
        }
        self.collectionStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_collectionStatistics(&mut self) -> CollectionStatistics {
        self.collectionStatistics.take().unwrap_or_else(|| CollectionStatistics::new())
    }
}

impl ::protobuf::Message for ColumnStatistics {
    fn is_initialized(&self) -> bool {
        for v in &self.intStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.doubleStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stringStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bucketStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.decimalStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dateStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.binaryStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.timestampStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collectionStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.numberOfValues = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.intStatistics)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.doubleStatistics)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stringStatistics)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bucketStatistics)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.decimalStatistics)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dateStatistics)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.binaryStatistics)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timestampStatistics)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasNull = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytesOnDisk = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.collectionStatistics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.numberOfValues {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.intStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.doubleStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stringStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bucketStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.decimalStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dateStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.binaryStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.timestampStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.hasNull {
            my_size += 2;
        }
        if let Some(v) = self.bytesOnDisk {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.collectionStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.numberOfValues {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.intStatistics.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.doubleStatistics.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stringStatistics.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bucketStatistics.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.decimalStatistics.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dateStatistics.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.binaryStatistics.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.timestampStatistics.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.hasNull {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.bytesOnDisk {
            os.write_uint64(11, v)?;
        }
        if let Some(ref v) = self.collectionStatistics.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColumnStatistics {
        ColumnStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "numberOfValues",
                |m: &ColumnStatistics| { &m.numberOfValues },
                |m: &mut ColumnStatistics| { &mut m.numberOfValues },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IntegerStatistics>>(
                "intStatistics",
                |m: &ColumnStatistics| { &m.intStatistics },
                |m: &mut ColumnStatistics| { &mut m.intStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DoubleStatistics>>(
                "doubleStatistics",
                |m: &ColumnStatistics| { &m.doubleStatistics },
                |m: &mut ColumnStatistics| { &mut m.doubleStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringStatistics>>(
                "stringStatistics",
                |m: &ColumnStatistics| { &m.stringStatistics },
                |m: &mut ColumnStatistics| { &mut m.stringStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BucketStatistics>>(
                "bucketStatistics",
                |m: &ColumnStatistics| { &m.bucketStatistics },
                |m: &mut ColumnStatistics| { &mut m.bucketStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DecimalStatistics>>(
                "decimalStatistics",
                |m: &ColumnStatistics| { &m.decimalStatistics },
                |m: &mut ColumnStatistics| { &mut m.decimalStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DateStatistics>>(
                "dateStatistics",
                |m: &ColumnStatistics| { &m.dateStatistics },
                |m: &mut ColumnStatistics| { &mut m.dateStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BinaryStatistics>>(
                "binaryStatistics",
                |m: &ColumnStatistics| { &m.binaryStatistics },
                |m: &mut ColumnStatistics| { &mut m.binaryStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimestampStatistics>>(
                "timestampStatistics",
                |m: &ColumnStatistics| { &m.timestampStatistics },
                |m: &mut ColumnStatistics| { &mut m.timestampStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasNull",
                |m: &ColumnStatistics| { &m.hasNull },
                |m: &mut ColumnStatistics| { &mut m.hasNull },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytesOnDisk",
                |m: &ColumnStatistics| { &m.bytesOnDisk },
                |m: &mut ColumnStatistics| { &mut m.bytesOnDisk },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CollectionStatistics>>(
                "collectionStatistics",
                |m: &ColumnStatistics| { &m.collectionStatistics },
                |m: &mut ColumnStatistics| { &mut m.collectionStatistics },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColumnStatistics>(
                "ColumnStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ColumnStatistics {
        static instance: ::protobuf::rt::LazyV2<ColumnStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ColumnStatistics::new)
    }
}

impl ::protobuf::Clear for ColumnStatistics {
    fn clear(&mut self) {
        self.numberOfValues = ::std::option::Option::None;
        self.intStatistics.clear();
        self.doubleStatistics.clear();
        self.stringStatistics.clear();
        self.bucketStatistics.clear();
        self.decimalStatistics.clear();
        self.dateStatistics.clear();
        self.binaryStatistics.clear();
        self.timestampStatistics.clear();
        self.hasNull = ::std::option::Option::None;
        self.bytesOnDisk = ::std::option::Option::None;
        self.collectionStatistics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColumnStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowIndexEntry {
    // message fields
    pub positions: ::std::vec::Vec<u64>,
    pub statistics: ::protobuf::SingularPtrField<ColumnStatistics>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowIndexEntry {
    fn default() -> &'a RowIndexEntry {
        <RowIndexEntry as ::protobuf::Message>::default_instance()
    }
}

impl RowIndexEntry {
    pub fn new() -> RowIndexEntry {
        ::std::default::Default::default()
    }

    // repeated uint64 positions = 1;


    pub fn get_positions(&self) -> &[u64] {
        &self.positions
    }
    pub fn clear_positions(&mut self) {
        self.positions.clear();
    }

    // Param is passed by value, moved
    pub fn set_positions(&mut self, v: ::std::vec::Vec<u64>) {
        self.positions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_positions(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.positions
    }

    // Take field
    pub fn take_positions(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.positions, ::std::vec::Vec::new())
    }

    // optional .orc.proto.ColumnStatistics statistics = 2;


    pub fn get_statistics(&self) -> &ColumnStatistics {
        self.statistics.as_ref().unwrap_or_else(|| <ColumnStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statistics(&mut self) {
        self.statistics.clear();
    }

    pub fn has_statistics(&self) -> bool {
        self.statistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statistics(&mut self, v: ColumnStatistics) {
        self.statistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statistics(&mut self) -> &mut ColumnStatistics {
        if self.statistics.is_none() {
            self.statistics.set_default();
        }
        self.statistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_statistics(&mut self) -> ColumnStatistics {
        self.statistics.take().unwrap_or_else(|| ColumnStatistics::new())
    }
}

impl ::protobuf::Message for RowIndexEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.statistics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.positions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statistics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.positions.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(1, &self.positions);
        }
        if let Some(ref v) = self.statistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.positions.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.positions))?;
            for v in &self.positions {
                os.write_uint64_no_tag(*v)?;
            };
        }
        if let Some(ref v) = self.statistics.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowIndexEntry {
        RowIndexEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "positions",
                |m: &RowIndexEntry| { &m.positions },
                |m: &mut RowIndexEntry| { &mut m.positions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColumnStatistics>>(
                "statistics",
                |m: &RowIndexEntry| { &m.statistics },
                |m: &mut RowIndexEntry| { &mut m.statistics },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowIndexEntry>(
                "RowIndexEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowIndexEntry {
        static instance: ::protobuf::rt::LazyV2<RowIndexEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowIndexEntry::new)
    }
}

impl ::protobuf::Clear for RowIndexEntry {
    fn clear(&mut self) {
        self.positions.clear();
        self.statistics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowIndexEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowIndexEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowIndex {
    // message fields
    pub entry: ::protobuf::RepeatedField<RowIndexEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowIndex {
    fn default() -> &'a RowIndex {
        <RowIndex as ::protobuf::Message>::default_instance()
    }
}

impl RowIndex {
    pub fn new() -> RowIndex {
        ::std::default::Default::default()
    }

    // repeated .orc.proto.RowIndexEntry entry = 1;


    pub fn get_entry(&self) -> &[RowIndexEntry] {
        &self.entry
    }
    pub fn clear_entry(&mut self) {
        self.entry.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry(&mut self, v: ::protobuf::RepeatedField<RowIndexEntry>) {
        self.entry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry(&mut self) -> &mut ::protobuf::RepeatedField<RowIndexEntry> {
        &mut self.entry
    }

    // Take field
    pub fn take_entry(&mut self) -> ::protobuf::RepeatedField<RowIndexEntry> {
        ::std::mem::replace(&mut self.entry, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RowIndex {
    fn is_initialized(&self) -> bool {
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowIndex {
        RowIndex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowIndexEntry>>(
                "entry",
                |m: &RowIndex| { &m.entry },
                |m: &mut RowIndex| { &mut m.entry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowIndex>(
                "RowIndex",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowIndex {
        static instance: ::protobuf::rt::LazyV2<RowIndex> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowIndex::new)
    }
}

impl ::protobuf::Clear for RowIndex {
    fn clear(&mut self) {
        self.entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BloomFilter {
    // message fields
    numHashFunctions: ::std::option::Option<u32>,
    pub bitset: ::std::vec::Vec<u64>,
    utf8bitset: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BloomFilter {
    fn default() -> &'a BloomFilter {
        <BloomFilter as ::protobuf::Message>::default_instance()
    }
}

impl BloomFilter {
    pub fn new() -> BloomFilter {
        ::std::default::Default::default()
    }

    // optional uint32 numHashFunctions = 1;


    pub fn get_numHashFunctions(&self) -> u32 {
        self.numHashFunctions.unwrap_or(0)
    }
    pub fn clear_numHashFunctions(&mut self) {
        self.numHashFunctions = ::std::option::Option::None;
    }

    pub fn has_numHashFunctions(&self) -> bool {
        self.numHashFunctions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numHashFunctions(&mut self, v: u32) {
        self.numHashFunctions = ::std::option::Option::Some(v);
    }

    // repeated fixed64 bitset = 2;


    pub fn get_bitset(&self) -> &[u64] {
        &self.bitset
    }
    pub fn clear_bitset(&mut self) {
        self.bitset.clear();
    }

    // Param is passed by value, moved
    pub fn set_bitset(&mut self, v: ::std::vec::Vec<u64>) {
        self.bitset = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bitset(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.bitset
    }

    // Take field
    pub fn take_bitset(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.bitset, ::std::vec::Vec::new())
    }

    // optional bytes utf8bitset = 3;


    pub fn get_utf8bitset(&self) -> &[u8] {
        match self.utf8bitset.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_utf8bitset(&mut self) {
        self.utf8bitset.clear();
    }

    pub fn has_utf8bitset(&self) -> bool {
        self.utf8bitset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utf8bitset(&mut self, v: ::std::vec::Vec<u8>) {
        self.utf8bitset = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_utf8bitset(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.utf8bitset.is_none() {
            self.utf8bitset.set_default();
        }
        self.utf8bitset.as_mut().unwrap()
    }

    // Take field
    pub fn take_utf8bitset(&mut self) -> ::std::vec::Vec<u8> {
        self.utf8bitset.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BloomFilter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numHashFunctions = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.bitset)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.utf8bitset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.numHashFunctions {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 9 * self.bitset.len() as u32;
        if let Some(ref v) = self.utf8bitset.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.numHashFunctions {
            os.write_uint32(1, v)?;
        }
        for v in &self.bitset {
            os.write_fixed64(2, *v)?;
        };
        if let Some(ref v) = self.utf8bitset.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BloomFilter {
        BloomFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "numHashFunctions",
                |m: &BloomFilter| { &m.numHashFunctions },
                |m: &mut BloomFilter| { &mut m.numHashFunctions },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "bitset",
                |m: &BloomFilter| { &m.bitset },
                |m: &mut BloomFilter| { &mut m.bitset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "utf8bitset",
                |m: &BloomFilter| { &m.utf8bitset },
                |m: &mut BloomFilter| { &mut m.utf8bitset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BloomFilter>(
                "BloomFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BloomFilter {
        static instance: ::protobuf::rt::LazyV2<BloomFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BloomFilter::new)
    }
}

impl ::protobuf::Clear for BloomFilter {
    fn clear(&mut self) {
        self.numHashFunctions = ::std::option::Option::None;
        self.bitset.clear();
        self.utf8bitset.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BloomFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BloomFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BloomFilterIndex {
    // message fields
    pub bloomFilter: ::protobuf::RepeatedField<BloomFilter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BloomFilterIndex {
    fn default() -> &'a BloomFilterIndex {
        <BloomFilterIndex as ::protobuf::Message>::default_instance()
    }
}

impl BloomFilterIndex {
    pub fn new() -> BloomFilterIndex {
        ::std::default::Default::default()
    }

    // repeated .orc.proto.BloomFilter bloomFilter = 1;


    pub fn get_bloomFilter(&self) -> &[BloomFilter] {
        &self.bloomFilter
    }
    pub fn clear_bloomFilter(&mut self) {
        self.bloomFilter.clear();
    }

    // Param is passed by value, moved
    pub fn set_bloomFilter(&mut self, v: ::protobuf::RepeatedField<BloomFilter>) {
        self.bloomFilter = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bloomFilter(&mut self) -> &mut ::protobuf::RepeatedField<BloomFilter> {
        &mut self.bloomFilter
    }

    // Take field
    pub fn take_bloomFilter(&mut self) -> ::protobuf::RepeatedField<BloomFilter> {
        ::std::mem::replace(&mut self.bloomFilter, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BloomFilterIndex {
    fn is_initialized(&self) -> bool {
        for v in &self.bloomFilter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bloomFilter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.bloomFilter {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.bloomFilter {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BloomFilterIndex {
        BloomFilterIndex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BloomFilter>>(
                "bloomFilter",
                |m: &BloomFilterIndex| { &m.bloomFilter },
                |m: &mut BloomFilterIndex| { &mut m.bloomFilter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BloomFilterIndex>(
                "BloomFilterIndex",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BloomFilterIndex {
        static instance: ::protobuf::rt::LazyV2<BloomFilterIndex> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BloomFilterIndex::new)
    }
}

impl ::protobuf::Clear for BloomFilterIndex {
    fn clear(&mut self) {
        self.bloomFilter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BloomFilterIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BloomFilterIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Stream {
    // message fields
    kind: ::std::option::Option<Stream_Kind>,
    column: ::std::option::Option<u32>,
    length: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Stream {
    fn default() -> &'a Stream {
        <Stream as ::protobuf::Message>::default_instance()
    }
}

impl Stream {
    pub fn new() -> Stream {
        ::std::default::Default::default()
    }

    // optional .orc.proto.Stream.Kind kind = 1;


    pub fn get_kind(&self) -> Stream_Kind {
        self.kind.unwrap_or(Stream_Kind::PRESENT)
    }
    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: Stream_Kind) {
        self.kind = ::std::option::Option::Some(v);
    }

    // optional uint32 column = 2;


    pub fn get_column(&self) -> u32 {
        self.column.unwrap_or(0)
    }
    pub fn clear_column(&mut self) {
        self.column = ::std::option::Option::None;
    }

    pub fn has_column(&self) -> bool {
        self.column.is_some()
    }

    // Param is passed by value, moved
    pub fn set_column(&mut self, v: u32) {
        self.column = ::std::option::Option::Some(v);
    }

    // optional uint64 length = 3;


    pub fn get_length(&self) -> u64 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Stream {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.column = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.kind {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.column {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.kind {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.column {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.length {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Stream {
        Stream::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Stream_Kind>>(
                "kind",
                |m: &Stream| { &m.kind },
                |m: &mut Stream| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "column",
                |m: &Stream| { &m.column },
                |m: &mut Stream| { &mut m.column },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "length",
                |m: &Stream| { &m.length },
                |m: &mut Stream| { &mut m.length },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Stream>(
                "Stream",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Stream {
        static instance: ::protobuf::rt::LazyV2<Stream> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Stream::new)
    }
}

impl ::protobuf::Clear for Stream {
    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.column = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Stream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Stream {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Stream_Kind {
    PRESENT = 0,
    DATA = 1,
    LENGTH = 2,
    DICTIONARY_DATA = 3,
    DICTIONARY_COUNT = 4,
    SECONDARY = 5,
    ROW_INDEX = 6,
    BLOOM_FILTER = 7,
    BLOOM_FILTER_UTF8 = 8,
    ENCRYPTED_INDEX = 9,
    ENCRYPTED_DATA = 10,
    STRIPE_STATISTICS = 100,
    FILE_STATISTICS = 101,
}

impl ::protobuf::ProtobufEnum for Stream_Kind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Stream_Kind> {
        match value {
            0 => ::std::option::Option::Some(Stream_Kind::PRESENT),
            1 => ::std::option::Option::Some(Stream_Kind::DATA),
            2 => ::std::option::Option::Some(Stream_Kind::LENGTH),
            3 => ::std::option::Option::Some(Stream_Kind::DICTIONARY_DATA),
            4 => ::std::option::Option::Some(Stream_Kind::DICTIONARY_COUNT),
            5 => ::std::option::Option::Some(Stream_Kind::SECONDARY),
            6 => ::std::option::Option::Some(Stream_Kind::ROW_INDEX),
            7 => ::std::option::Option::Some(Stream_Kind::BLOOM_FILTER),
            8 => ::std::option::Option::Some(Stream_Kind::BLOOM_FILTER_UTF8),
            9 => ::std::option::Option::Some(Stream_Kind::ENCRYPTED_INDEX),
            10 => ::std::option::Option::Some(Stream_Kind::ENCRYPTED_DATA),
            100 => ::std::option::Option::Some(Stream_Kind::STRIPE_STATISTICS),
            101 => ::std::option::Option::Some(Stream_Kind::FILE_STATISTICS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Stream_Kind] = &[
            Stream_Kind::PRESENT,
            Stream_Kind::DATA,
            Stream_Kind::LENGTH,
            Stream_Kind::DICTIONARY_DATA,
            Stream_Kind::DICTIONARY_COUNT,
            Stream_Kind::SECONDARY,
            Stream_Kind::ROW_INDEX,
            Stream_Kind::BLOOM_FILTER,
            Stream_Kind::BLOOM_FILTER_UTF8,
            Stream_Kind::ENCRYPTED_INDEX,
            Stream_Kind::ENCRYPTED_DATA,
            Stream_Kind::STRIPE_STATISTICS,
            Stream_Kind::FILE_STATISTICS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Stream_Kind>("Stream.Kind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Stream_Kind {
}

impl ::std::default::Default for Stream_Kind {
    fn default() -> Self {
        Stream_Kind::PRESENT
    }
}

impl ::protobuf::reflect::ProtobufValue for Stream_Kind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ColumnEncoding {
    // message fields
    kind: ::std::option::Option<ColumnEncoding_Kind>,
    dictionarySize: ::std::option::Option<u32>,
    bloomEncoding: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColumnEncoding {
    fn default() -> &'a ColumnEncoding {
        <ColumnEncoding as ::protobuf::Message>::default_instance()
    }
}

impl ColumnEncoding {
    pub fn new() -> ColumnEncoding {
        ::std::default::Default::default()
    }

    // optional .orc.proto.ColumnEncoding.Kind kind = 1;


    pub fn get_kind(&self) -> ColumnEncoding_Kind {
        self.kind.unwrap_or(ColumnEncoding_Kind::DIRECT)
    }
    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ColumnEncoding_Kind) {
        self.kind = ::std::option::Option::Some(v);
    }

    // optional uint32 dictionarySize = 2;


    pub fn get_dictionarySize(&self) -> u32 {
        self.dictionarySize.unwrap_or(0)
    }
    pub fn clear_dictionarySize(&mut self) {
        self.dictionarySize = ::std::option::Option::None;
    }

    pub fn has_dictionarySize(&self) -> bool {
        self.dictionarySize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dictionarySize(&mut self, v: u32) {
        self.dictionarySize = ::std::option::Option::Some(v);
    }

    // optional uint32 bloomEncoding = 3;


    pub fn get_bloomEncoding(&self) -> u32 {
        self.bloomEncoding.unwrap_or(0)
    }
    pub fn clear_bloomEncoding(&mut self) {
        self.bloomEncoding = ::std::option::Option::None;
    }

    pub fn has_bloomEncoding(&self) -> bool {
        self.bloomEncoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bloomEncoding(&mut self, v: u32) {
        self.bloomEncoding = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ColumnEncoding {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dictionarySize = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bloomEncoding = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.kind {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.dictionarySize {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bloomEncoding {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.kind {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.dictionarySize {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bloomEncoding {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColumnEncoding {
        ColumnEncoding::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ColumnEncoding_Kind>>(
                "kind",
                |m: &ColumnEncoding| { &m.kind },
                |m: &mut ColumnEncoding| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dictionarySize",
                |m: &ColumnEncoding| { &m.dictionarySize },
                |m: &mut ColumnEncoding| { &mut m.dictionarySize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bloomEncoding",
                |m: &ColumnEncoding| { &m.bloomEncoding },
                |m: &mut ColumnEncoding| { &mut m.bloomEncoding },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColumnEncoding>(
                "ColumnEncoding",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ColumnEncoding {
        static instance: ::protobuf::rt::LazyV2<ColumnEncoding> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ColumnEncoding::new)
    }
}

impl ::protobuf::Clear for ColumnEncoding {
    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.dictionarySize = ::std::option::Option::None;
        self.bloomEncoding = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColumnEncoding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnEncoding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ColumnEncoding_Kind {
    DIRECT = 0,
    DICTIONARY = 1,
    DIRECT_V2 = 2,
    DICTIONARY_V2 = 3,
}

impl ::protobuf::ProtobufEnum for ColumnEncoding_Kind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ColumnEncoding_Kind> {
        match value {
            0 => ::std::option::Option::Some(ColumnEncoding_Kind::DIRECT),
            1 => ::std::option::Option::Some(ColumnEncoding_Kind::DICTIONARY),
            2 => ::std::option::Option::Some(ColumnEncoding_Kind::DIRECT_V2),
            3 => ::std::option::Option::Some(ColumnEncoding_Kind::DICTIONARY_V2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ColumnEncoding_Kind] = &[
            ColumnEncoding_Kind::DIRECT,
            ColumnEncoding_Kind::DICTIONARY,
            ColumnEncoding_Kind::DIRECT_V2,
            ColumnEncoding_Kind::DICTIONARY_V2,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ColumnEncoding_Kind>("ColumnEncoding.Kind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ColumnEncoding_Kind {
}

impl ::std::default::Default for ColumnEncoding_Kind {
    fn default() -> Self {
        ColumnEncoding_Kind::DIRECT
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnEncoding_Kind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StripeEncryptionVariant {
    // message fields
    pub streams: ::protobuf::RepeatedField<Stream>,
    pub encoding: ::protobuf::RepeatedField<ColumnEncoding>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StripeEncryptionVariant {
    fn default() -> &'a StripeEncryptionVariant {
        <StripeEncryptionVariant as ::protobuf::Message>::default_instance()
    }
}

impl StripeEncryptionVariant {
    pub fn new() -> StripeEncryptionVariant {
        ::std::default::Default::default()
    }

    // repeated .orc.proto.Stream streams = 1;


    pub fn get_streams(&self) -> &[Stream] {
        &self.streams
    }
    pub fn clear_streams(&mut self) {
        self.streams.clear();
    }

    // Param is passed by value, moved
    pub fn set_streams(&mut self, v: ::protobuf::RepeatedField<Stream>) {
        self.streams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_streams(&mut self) -> &mut ::protobuf::RepeatedField<Stream> {
        &mut self.streams
    }

    // Take field
    pub fn take_streams(&mut self) -> ::protobuf::RepeatedField<Stream> {
        ::std::mem::replace(&mut self.streams, ::protobuf::RepeatedField::new())
    }

    // repeated .orc.proto.ColumnEncoding encoding = 2;


    pub fn get_encoding(&self) -> &[ColumnEncoding] {
        &self.encoding
    }
    pub fn clear_encoding(&mut self) {
        self.encoding.clear();
    }

    // Param is passed by value, moved
    pub fn set_encoding(&mut self, v: ::protobuf::RepeatedField<ColumnEncoding>) {
        self.encoding = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encoding(&mut self) -> &mut ::protobuf::RepeatedField<ColumnEncoding> {
        &mut self.encoding
    }

    // Take field
    pub fn take_encoding(&mut self) -> ::protobuf::RepeatedField<ColumnEncoding> {
        ::std::mem::replace(&mut self.encoding, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StripeEncryptionVariant {
    fn is_initialized(&self) -> bool {
        for v in &self.streams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encoding {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.streams)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.encoding)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.streams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.encoding {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.streams {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.encoding {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StripeEncryptionVariant {
        StripeEncryptionVariant::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stream>>(
                "streams",
                |m: &StripeEncryptionVariant| { &m.streams },
                |m: &mut StripeEncryptionVariant| { &mut m.streams },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColumnEncoding>>(
                "encoding",
                |m: &StripeEncryptionVariant| { &m.encoding },
                |m: &mut StripeEncryptionVariant| { &mut m.encoding },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StripeEncryptionVariant>(
                "StripeEncryptionVariant",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StripeEncryptionVariant {
        static instance: ::protobuf::rt::LazyV2<StripeEncryptionVariant> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StripeEncryptionVariant::new)
    }
}

impl ::protobuf::Clear for StripeEncryptionVariant {
    fn clear(&mut self) {
        self.streams.clear();
        self.encoding.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StripeEncryptionVariant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StripeEncryptionVariant {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StripeFooter {
    // message fields
    pub streams: ::protobuf::RepeatedField<Stream>,
    pub columns: ::protobuf::RepeatedField<ColumnEncoding>,
    writerTimezone: ::protobuf::SingularField<::std::string::String>,
    pub encryption: ::protobuf::RepeatedField<StripeEncryptionVariant>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StripeFooter {
    fn default() -> &'a StripeFooter {
        <StripeFooter as ::protobuf::Message>::default_instance()
    }
}

impl StripeFooter {
    pub fn new() -> StripeFooter {
        ::std::default::Default::default()
    }

    // repeated .orc.proto.Stream streams = 1;


    pub fn get_streams(&self) -> &[Stream] {
        &self.streams
    }
    pub fn clear_streams(&mut self) {
        self.streams.clear();
    }

    // Param is passed by value, moved
    pub fn set_streams(&mut self, v: ::protobuf::RepeatedField<Stream>) {
        self.streams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_streams(&mut self) -> &mut ::protobuf::RepeatedField<Stream> {
        &mut self.streams
    }

    // Take field
    pub fn take_streams(&mut self) -> ::protobuf::RepeatedField<Stream> {
        ::std::mem::replace(&mut self.streams, ::protobuf::RepeatedField::new())
    }

    // repeated .orc.proto.ColumnEncoding columns = 2;


    pub fn get_columns(&self) -> &[ColumnEncoding] {
        &self.columns
    }
    pub fn clear_columns(&mut self) {
        self.columns.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns(&mut self, v: ::protobuf::RepeatedField<ColumnEncoding>) {
        self.columns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns(&mut self) -> &mut ::protobuf::RepeatedField<ColumnEncoding> {
        &mut self.columns
    }

    // Take field
    pub fn take_columns(&mut self) -> ::protobuf::RepeatedField<ColumnEncoding> {
        ::std::mem::replace(&mut self.columns, ::protobuf::RepeatedField::new())
    }

    // optional string writerTimezone = 3;


    pub fn get_writerTimezone(&self) -> &str {
        match self.writerTimezone.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_writerTimezone(&mut self) {
        self.writerTimezone.clear();
    }

    pub fn has_writerTimezone(&self) -> bool {
        self.writerTimezone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writerTimezone(&mut self, v: ::std::string::String) {
        self.writerTimezone = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_writerTimezone(&mut self) -> &mut ::std::string::String {
        if self.writerTimezone.is_none() {
            self.writerTimezone.set_default();
        }
        self.writerTimezone.as_mut().unwrap()
    }

    // Take field
    pub fn take_writerTimezone(&mut self) -> ::std::string::String {
        self.writerTimezone.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .orc.proto.StripeEncryptionVariant encryption = 4;


    pub fn get_encryption(&self) -> &[StripeEncryptionVariant] {
        &self.encryption
    }
    pub fn clear_encryption(&mut self) {
        self.encryption.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryption(&mut self, v: ::protobuf::RepeatedField<StripeEncryptionVariant>) {
        self.encryption = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encryption(&mut self) -> &mut ::protobuf::RepeatedField<StripeEncryptionVariant> {
        &mut self.encryption
    }

    // Take field
    pub fn take_encryption(&mut self) -> ::protobuf::RepeatedField<StripeEncryptionVariant> {
        ::std::mem::replace(&mut self.encryption, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StripeFooter {
    fn is_initialized(&self) -> bool {
        for v in &self.streams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.columns {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryption {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.streams)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.columns)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.writerTimezone)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.encryption)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.streams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.columns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.writerTimezone.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.encryption {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.streams {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.columns {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.writerTimezone.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.encryption {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StripeFooter {
        StripeFooter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stream>>(
                "streams",
                |m: &StripeFooter| { &m.streams },
                |m: &mut StripeFooter| { &mut m.streams },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColumnEncoding>>(
                "columns",
                |m: &StripeFooter| { &m.columns },
                |m: &mut StripeFooter| { &mut m.columns },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "writerTimezone",
                |m: &StripeFooter| { &m.writerTimezone },
                |m: &mut StripeFooter| { &mut m.writerTimezone },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StripeEncryptionVariant>>(
                "encryption",
                |m: &StripeFooter| { &m.encryption },
                |m: &mut StripeFooter| { &mut m.encryption },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StripeFooter>(
                "StripeFooter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StripeFooter {
        static instance: ::protobuf::rt::LazyV2<StripeFooter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StripeFooter::new)
    }
}

impl ::protobuf::Clear for StripeFooter {
    fn clear(&mut self) {
        self.streams.clear();
        self.columns.clear();
        self.writerTimezone.clear();
        self.encryption.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StripeFooter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StripeFooter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringPair {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringPair {
    fn default() -> &'a StringPair {
        <StringPair as ::protobuf::Message>::default_instance()
    }
}

impl StringPair {
    pub fn new() -> StringPair {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for StringPair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringPair {
        StringPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &StringPair| { &m.key },
                |m: &mut StringPair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &StringPair| { &m.value },
                |m: &mut StringPair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringPair>(
                "StringPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringPair {
        static instance: ::protobuf::rt::LazyV2<StringPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringPair::new)
    }
}

impl ::protobuf::Clear for StringPair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type {
    // message fields
    kind: ::std::option::Option<Type_Kind>,
    pub subtypes: ::std::vec::Vec<u32>,
    pub fieldNames: ::protobuf::RepeatedField<::std::string::String>,
    maximumLength: ::std::option::Option<u32>,
    precision: ::std::option::Option<u32>,
    scale: ::std::option::Option<u32>,
    pub attributes: ::protobuf::RepeatedField<StringPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type {
    fn default() -> &'a Type {
        <Type as ::protobuf::Message>::default_instance()
    }
}

impl Type {
    pub fn new() -> Type {
        ::std::default::Default::default()
    }

    // optional .orc.proto.Type.Kind kind = 1;


    pub fn get_kind(&self) -> Type_Kind {
        self.kind.unwrap_or(Type_Kind::BOOLEAN)
    }
    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: Type_Kind) {
        self.kind = ::std::option::Option::Some(v);
    }

    // repeated uint32 subtypes = 2;


    pub fn get_subtypes(&self) -> &[u32] {
        &self.subtypes
    }
    pub fn clear_subtypes(&mut self) {
        self.subtypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_subtypes(&mut self, v: ::std::vec::Vec<u32>) {
        self.subtypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subtypes(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.subtypes
    }

    // Take field
    pub fn take_subtypes(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.subtypes, ::std::vec::Vec::new())
    }

    // repeated string fieldNames = 3;


    pub fn get_fieldNames(&self) -> &[::std::string::String] {
        &self.fieldNames
    }
    pub fn clear_fieldNames(&mut self) {
        self.fieldNames.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldNames(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.fieldNames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldNames(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.fieldNames
    }

    // Take field
    pub fn take_fieldNames(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.fieldNames, ::protobuf::RepeatedField::new())
    }

    // optional uint32 maximumLength = 4;


    pub fn get_maximumLength(&self) -> u32 {
        self.maximumLength.unwrap_or(0)
    }
    pub fn clear_maximumLength(&mut self) {
        self.maximumLength = ::std::option::Option::None;
    }

    pub fn has_maximumLength(&self) -> bool {
        self.maximumLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximumLength(&mut self, v: u32) {
        self.maximumLength = ::std::option::Option::Some(v);
    }

    // optional uint32 precision = 5;


    pub fn get_precision(&self) -> u32 {
        self.precision.unwrap_or(0)
    }
    pub fn clear_precision(&mut self) {
        self.precision = ::std::option::Option::None;
    }

    pub fn has_precision(&self) -> bool {
        self.precision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_precision(&mut self, v: u32) {
        self.precision = ::std::option::Option::Some(v);
    }

    // optional uint32 scale = 6;


    pub fn get_scale(&self) -> u32 {
        self.scale.unwrap_or(0)
    }
    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: u32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // repeated .orc.proto.StringPair attributes = 7;


    pub fn get_attributes(&self) -> &[StringPair] {
        &self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<StringPair>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::protobuf::RepeatedField<StringPair> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<StringPair> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Type {
    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.subtypes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.fieldNames)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maximumLength = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.precision = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scale = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.kind {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if !self.subtypes.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, &self.subtypes);
        }
        for value in &self.fieldNames {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.maximumLength {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.precision {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scale {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.kind {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if !self.subtypes.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.subtypes))?;
            for v in &self.subtypes {
                os.write_uint32_no_tag(*v)?;
            };
        }
        for v in &self.fieldNames {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.maximumLength {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.precision {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scale {
            os.write_uint32(6, v)?;
        }
        for v in &self.attributes {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type {
        Type::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Type_Kind>>(
                "kind",
                |m: &Type| { &m.kind },
                |m: &mut Type| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "subtypes",
                |m: &Type| { &m.subtypes },
                |m: &mut Type| { &mut m.subtypes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fieldNames",
                |m: &Type| { &m.fieldNames },
                |m: &mut Type| { &mut m.fieldNames },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maximumLength",
                |m: &Type| { &m.maximumLength },
                |m: &mut Type| { &mut m.maximumLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "precision",
                |m: &Type| { &m.precision },
                |m: &mut Type| { &mut m.precision },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "scale",
                |m: &Type| { &m.scale },
                |m: &mut Type| { &mut m.scale },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringPair>>(
                "attributes",
                |m: &Type| { &m.attributes },
                |m: &mut Type| { &mut m.attributes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Type>(
                "Type",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Type {
        static instance: ::protobuf::rt::LazyV2<Type> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Type::new)
    }
}

impl ::protobuf::Clear for Type {
    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.subtypes.clear();
        self.fieldNames.clear();
        self.maximumLength = ::std::option::Option::None;
        self.precision = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Type_Kind {
    BOOLEAN = 0,
    BYTE = 1,
    SHORT = 2,
    INT = 3,
    LONG = 4,
    FLOAT = 5,
    DOUBLE = 6,
    STRING = 7,
    BINARY = 8,
    TIMESTAMP = 9,
    LIST = 10,
    MAP = 11,
    STRUCT = 12,
    UNION = 13,
    DECIMAL = 14,
    DATE = 15,
    VARCHAR = 16,
    CHAR = 17,
    TIMESTAMP_INSTANT = 18,
}

impl ::protobuf::ProtobufEnum for Type_Kind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Type_Kind> {
        match value {
            0 => ::std::option::Option::Some(Type_Kind::BOOLEAN),
            1 => ::std::option::Option::Some(Type_Kind::BYTE),
            2 => ::std::option::Option::Some(Type_Kind::SHORT),
            3 => ::std::option::Option::Some(Type_Kind::INT),
            4 => ::std::option::Option::Some(Type_Kind::LONG),
            5 => ::std::option::Option::Some(Type_Kind::FLOAT),
            6 => ::std::option::Option::Some(Type_Kind::DOUBLE),
            7 => ::std::option::Option::Some(Type_Kind::STRING),
            8 => ::std::option::Option::Some(Type_Kind::BINARY),
            9 => ::std::option::Option::Some(Type_Kind::TIMESTAMP),
            10 => ::std::option::Option::Some(Type_Kind::LIST),
            11 => ::std::option::Option::Some(Type_Kind::MAP),
            12 => ::std::option::Option::Some(Type_Kind::STRUCT),
            13 => ::std::option::Option::Some(Type_Kind::UNION),
            14 => ::std::option::Option::Some(Type_Kind::DECIMAL),
            15 => ::std::option::Option::Some(Type_Kind::DATE),
            16 => ::std::option::Option::Some(Type_Kind::VARCHAR),
            17 => ::std::option::Option::Some(Type_Kind::CHAR),
            18 => ::std::option::Option::Some(Type_Kind::TIMESTAMP_INSTANT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Type_Kind] = &[
            Type_Kind::BOOLEAN,
            Type_Kind::BYTE,
            Type_Kind::SHORT,
            Type_Kind::INT,
            Type_Kind::LONG,
            Type_Kind::FLOAT,
            Type_Kind::DOUBLE,
            Type_Kind::STRING,
            Type_Kind::BINARY,
            Type_Kind::TIMESTAMP,
            Type_Kind::LIST,
            Type_Kind::MAP,
            Type_Kind::STRUCT,
            Type_Kind::UNION,
            Type_Kind::DECIMAL,
            Type_Kind::DATE,
            Type_Kind::VARCHAR,
            Type_Kind::CHAR,
            Type_Kind::TIMESTAMP_INSTANT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Type_Kind>("Type.Kind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Type_Kind {
}

impl ::std::default::Default for Type_Kind {
    fn default() -> Self {
        Type_Kind::BOOLEAN
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_Kind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StripeInformation {
    // message fields
    offset: ::std::option::Option<u64>,
    indexLength: ::std::option::Option<u64>,
    dataLength: ::std::option::Option<u64>,
    footerLength: ::std::option::Option<u64>,
    numberOfRows: ::std::option::Option<u64>,
    encryptStripeId: ::std::option::Option<u64>,
    pub encryptedLocalKeys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StripeInformation {
    fn default() -> &'a StripeInformation {
        <StripeInformation as ::protobuf::Message>::default_instance()
    }
}

impl StripeInformation {
    pub fn new() -> StripeInformation {
        ::std::default::Default::default()
    }

    // optional uint64 offset = 1;


    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint64 indexLength = 2;


    pub fn get_indexLength(&self) -> u64 {
        self.indexLength.unwrap_or(0)
    }
    pub fn clear_indexLength(&mut self) {
        self.indexLength = ::std::option::Option::None;
    }

    pub fn has_indexLength(&self) -> bool {
        self.indexLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_indexLength(&mut self, v: u64) {
        self.indexLength = ::std::option::Option::Some(v);
    }

    // optional uint64 dataLength = 3;


    pub fn get_dataLength(&self) -> u64 {
        self.dataLength.unwrap_or(0)
    }
    pub fn clear_dataLength(&mut self) {
        self.dataLength = ::std::option::Option::None;
    }

    pub fn has_dataLength(&self) -> bool {
        self.dataLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataLength(&mut self, v: u64) {
        self.dataLength = ::std::option::Option::Some(v);
    }

    // optional uint64 footerLength = 4;


    pub fn get_footerLength(&self) -> u64 {
        self.footerLength.unwrap_or(0)
    }
    pub fn clear_footerLength(&mut self) {
        self.footerLength = ::std::option::Option::None;
    }

    pub fn has_footerLength(&self) -> bool {
        self.footerLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_footerLength(&mut self, v: u64) {
        self.footerLength = ::std::option::Option::Some(v);
    }

    // optional uint64 numberOfRows = 5;


    pub fn get_numberOfRows(&self) -> u64 {
        self.numberOfRows.unwrap_or(0)
    }
    pub fn clear_numberOfRows(&mut self) {
        self.numberOfRows = ::std::option::Option::None;
    }

    pub fn has_numberOfRows(&self) -> bool {
        self.numberOfRows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberOfRows(&mut self, v: u64) {
        self.numberOfRows = ::std::option::Option::Some(v);
    }

    // optional uint64 encryptStripeId = 6;


    pub fn get_encryptStripeId(&self) -> u64 {
        self.encryptStripeId.unwrap_or(0)
    }
    pub fn clear_encryptStripeId(&mut self) {
        self.encryptStripeId = ::std::option::Option::None;
    }

    pub fn has_encryptStripeId(&self) -> bool {
        self.encryptStripeId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryptStripeId(&mut self, v: u64) {
        self.encryptStripeId = ::std::option::Option::Some(v);
    }

    // repeated bytes encryptedLocalKeys = 7;


    pub fn get_encryptedLocalKeys(&self) -> &[::std::vec::Vec<u8>] {
        &self.encryptedLocalKeys
    }
    pub fn clear_encryptedLocalKeys(&mut self) {
        self.encryptedLocalKeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryptedLocalKeys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.encryptedLocalKeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encryptedLocalKeys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.encryptedLocalKeys
    }

    // Take field
    pub fn take_encryptedLocalKeys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.encryptedLocalKeys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StripeInformation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.indexLength = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dataLength = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.footerLength = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.numberOfRows = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.encryptStripeId = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.encryptedLocalKeys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.indexLength {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dataLength {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.footerLength {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numberOfRows {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.encryptStripeId {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.encryptedLocalKeys {
            my_size += ::protobuf::rt::bytes_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.offset {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.indexLength {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.dataLength {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.footerLength {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.numberOfRows {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.encryptStripeId {
            os.write_uint64(6, v)?;
        }
        for v in &self.encryptedLocalKeys {
            os.write_bytes(7, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StripeInformation {
        StripeInformation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "offset",
                |m: &StripeInformation| { &m.offset },
                |m: &mut StripeInformation| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "indexLength",
                |m: &StripeInformation| { &m.indexLength },
                |m: &mut StripeInformation| { &mut m.indexLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "dataLength",
                |m: &StripeInformation| { &m.dataLength },
                |m: &mut StripeInformation| { &mut m.dataLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "footerLength",
                |m: &StripeInformation| { &m.footerLength },
                |m: &mut StripeInformation| { &mut m.footerLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "numberOfRows",
                |m: &StripeInformation| { &m.numberOfRows },
                |m: &mut StripeInformation| { &mut m.numberOfRows },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "encryptStripeId",
                |m: &StripeInformation| { &m.encryptStripeId },
                |m: &mut StripeInformation| { &mut m.encryptStripeId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "encryptedLocalKeys",
                |m: &StripeInformation| { &m.encryptedLocalKeys },
                |m: &mut StripeInformation| { &mut m.encryptedLocalKeys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StripeInformation>(
                "StripeInformation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StripeInformation {
        static instance: ::protobuf::rt::LazyV2<StripeInformation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StripeInformation::new)
    }
}

impl ::protobuf::Clear for StripeInformation {
    fn clear(&mut self) {
        self.offset = ::std::option::Option::None;
        self.indexLength = ::std::option::Option::None;
        self.dataLength = ::std::option::Option::None;
        self.footerLength = ::std::option::Option::None;
        self.numberOfRows = ::std::option::Option::None;
        self.encryptStripeId = ::std::option::Option::None;
        self.encryptedLocalKeys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StripeInformation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StripeInformation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserMetadataItem {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserMetadataItem {
    fn default() -> &'a UserMetadataItem {
        <UserMetadataItem as ::protobuf::Message>::default_instance()
    }
}

impl UserMetadataItem {
    pub fn new() -> UserMetadataItem {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        match self.value.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        self.value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UserMetadataItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserMetadataItem {
        UserMetadataItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UserMetadataItem| { &m.name },
                |m: &mut UserMetadataItem| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &UserMetadataItem| { &m.value },
                |m: &mut UserMetadataItem| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserMetadataItem>(
                "UserMetadataItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserMetadataItem {
        static instance: ::protobuf::rt::LazyV2<UserMetadataItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserMetadataItem::new)
    }
}

impl ::protobuf::Clear for UserMetadataItem {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserMetadataItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserMetadataItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StripeStatistics {
    // message fields
    pub colStats: ::protobuf::RepeatedField<ColumnStatistics>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StripeStatistics {
    fn default() -> &'a StripeStatistics {
        <StripeStatistics as ::protobuf::Message>::default_instance()
    }
}

impl StripeStatistics {
    pub fn new() -> StripeStatistics {
        ::std::default::Default::default()
    }

    // repeated .orc.proto.ColumnStatistics colStats = 1;


    pub fn get_colStats(&self) -> &[ColumnStatistics] {
        &self.colStats
    }
    pub fn clear_colStats(&mut self) {
        self.colStats.clear();
    }

    // Param is passed by value, moved
    pub fn set_colStats(&mut self, v: ::protobuf::RepeatedField<ColumnStatistics>) {
        self.colStats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_colStats(&mut self) -> &mut ::protobuf::RepeatedField<ColumnStatistics> {
        &mut self.colStats
    }

    // Take field
    pub fn take_colStats(&mut self) -> ::protobuf::RepeatedField<ColumnStatistics> {
        ::std::mem::replace(&mut self.colStats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StripeStatistics {
    fn is_initialized(&self) -> bool {
        for v in &self.colStats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.colStats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.colStats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.colStats {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StripeStatistics {
        StripeStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColumnStatistics>>(
                "colStats",
                |m: &StripeStatistics| { &m.colStats },
                |m: &mut StripeStatistics| { &mut m.colStats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StripeStatistics>(
                "StripeStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StripeStatistics {
        static instance: ::protobuf::rt::LazyV2<StripeStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StripeStatistics::new)
    }
}

impl ::protobuf::Clear for StripeStatistics {
    fn clear(&mut self) {
        self.colStats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StripeStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StripeStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Metadata {
    // message fields
    pub stripeStats: ::protobuf::RepeatedField<StripeStatistics>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Metadata {
    fn default() -> &'a Metadata {
        <Metadata as ::protobuf::Message>::default_instance()
    }
}

impl Metadata {
    pub fn new() -> Metadata {
        ::std::default::Default::default()
    }

    // repeated .orc.proto.StripeStatistics stripeStats = 1;


    pub fn get_stripeStats(&self) -> &[StripeStatistics] {
        &self.stripeStats
    }
    pub fn clear_stripeStats(&mut self) {
        self.stripeStats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stripeStats(&mut self, v: ::protobuf::RepeatedField<StripeStatistics>) {
        self.stripeStats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stripeStats(&mut self) -> &mut ::protobuf::RepeatedField<StripeStatistics> {
        &mut self.stripeStats
    }

    // Take field
    pub fn take_stripeStats(&mut self) -> ::protobuf::RepeatedField<StripeStatistics> {
        ::std::mem::replace(&mut self.stripeStats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Metadata {
    fn is_initialized(&self) -> bool {
        for v in &self.stripeStats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stripeStats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.stripeStats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.stripeStats {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Metadata {
        Metadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StripeStatistics>>(
                "stripeStats",
                |m: &Metadata| { &m.stripeStats },
                |m: &mut Metadata| { &mut m.stripeStats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Metadata>(
                "Metadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Metadata {
        static instance: ::protobuf::rt::LazyV2<Metadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Metadata::new)
    }
}

impl ::protobuf::Clear for Metadata {
    fn clear(&mut self) {
        self.stripeStats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Metadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ColumnarStripeStatistics {
    // message fields
    pub colStats: ::protobuf::RepeatedField<ColumnStatistics>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColumnarStripeStatistics {
    fn default() -> &'a ColumnarStripeStatistics {
        <ColumnarStripeStatistics as ::protobuf::Message>::default_instance()
    }
}

impl ColumnarStripeStatistics {
    pub fn new() -> ColumnarStripeStatistics {
        ::std::default::Default::default()
    }

    // repeated .orc.proto.ColumnStatistics colStats = 1;


    pub fn get_colStats(&self) -> &[ColumnStatistics] {
        &self.colStats
    }
    pub fn clear_colStats(&mut self) {
        self.colStats.clear();
    }

    // Param is passed by value, moved
    pub fn set_colStats(&mut self, v: ::protobuf::RepeatedField<ColumnStatistics>) {
        self.colStats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_colStats(&mut self) -> &mut ::protobuf::RepeatedField<ColumnStatistics> {
        &mut self.colStats
    }

    // Take field
    pub fn take_colStats(&mut self) -> ::protobuf::RepeatedField<ColumnStatistics> {
        ::std::mem::replace(&mut self.colStats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ColumnarStripeStatistics {
    fn is_initialized(&self) -> bool {
        for v in &self.colStats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.colStats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.colStats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.colStats {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColumnarStripeStatistics {
        ColumnarStripeStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColumnStatistics>>(
                "colStats",
                |m: &ColumnarStripeStatistics| { &m.colStats },
                |m: &mut ColumnarStripeStatistics| { &mut m.colStats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColumnarStripeStatistics>(
                "ColumnarStripeStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ColumnarStripeStatistics {
        static instance: ::protobuf::rt::LazyV2<ColumnarStripeStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ColumnarStripeStatistics::new)
    }
}

impl ::protobuf::Clear for ColumnarStripeStatistics {
    fn clear(&mut self) {
        self.colStats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColumnarStripeStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnarStripeStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileStatistics {
    // message fields
    pub column: ::protobuf::RepeatedField<ColumnStatistics>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileStatistics {
    fn default() -> &'a FileStatistics {
        <FileStatistics as ::protobuf::Message>::default_instance()
    }
}

impl FileStatistics {
    pub fn new() -> FileStatistics {
        ::std::default::Default::default()
    }

    // repeated .orc.proto.ColumnStatistics column = 1;


    pub fn get_column(&self) -> &[ColumnStatistics] {
        &self.column
    }
    pub fn clear_column(&mut self) {
        self.column.clear();
    }

    // Param is passed by value, moved
    pub fn set_column(&mut self, v: ::protobuf::RepeatedField<ColumnStatistics>) {
        self.column = v;
    }

    // Mutable pointer to the field.
    pub fn mut_column(&mut self) -> &mut ::protobuf::RepeatedField<ColumnStatistics> {
        &mut self.column
    }

    // Take field
    pub fn take_column(&mut self) -> ::protobuf::RepeatedField<ColumnStatistics> {
        ::std::mem::replace(&mut self.column, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FileStatistics {
    fn is_initialized(&self) -> bool {
        for v in &self.column {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.column)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.column {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.column {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileStatistics {
        FileStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColumnStatistics>>(
                "column",
                |m: &FileStatistics| { &m.column },
                |m: &mut FileStatistics| { &mut m.column },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileStatistics>(
                "FileStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileStatistics {
        static instance: ::protobuf::rt::LazyV2<FileStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileStatistics::new)
    }
}

impl ::protobuf::Clear for FileStatistics {
    fn clear(&mut self) {
        self.column.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataMask {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    pub maskParameters: ::protobuf::RepeatedField<::std::string::String>,
    pub columns: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMask {
    fn default() -> &'a DataMask {
        <DataMask as ::protobuf::Message>::default_instance()
    }
}

impl DataMask {
    pub fn new() -> DataMask {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string maskParameters = 2;


    pub fn get_maskParameters(&self) -> &[::std::string::String] {
        &self.maskParameters
    }
    pub fn clear_maskParameters(&mut self) {
        self.maskParameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_maskParameters(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.maskParameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_maskParameters(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.maskParameters
    }

    // Take field
    pub fn take_maskParameters(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.maskParameters, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 columns = 3;


    pub fn get_columns(&self) -> &[u32] {
        &self.columns
    }
    pub fn clear_columns(&mut self) {
        self.columns.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns(&mut self, v: ::std::vec::Vec<u32>) {
        self.columns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.columns
    }

    // Take field
    pub fn take_columns(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.columns, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DataMask {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.maskParameters)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.columns)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.maskParameters {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.columns.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.columns);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.maskParameters {
            os.write_string(2, &v)?;
        };
        if !self.columns.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.columns))?;
            for v in &self.columns {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMask {
        DataMask::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DataMask| { &m.name },
                |m: &mut DataMask| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "maskParameters",
                |m: &DataMask| { &m.maskParameters },
                |m: &mut DataMask| { &mut m.maskParameters },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "columns",
                |m: &DataMask| { &m.columns },
                |m: &mut DataMask| { &mut m.columns },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMask>(
                "DataMask",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMask {
        static instance: ::protobuf::rt::LazyV2<DataMask> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMask::new)
    }
}

impl ::protobuf::Clear for DataMask {
    fn clear(&mut self) {
        self.name.clear();
        self.maskParameters.clear();
        self.columns.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMask {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptionKey {
    // message fields
    keyName: ::protobuf::SingularField<::std::string::String>,
    keyVersion: ::std::option::Option<u32>,
    algorithm: ::std::option::Option<EncryptionAlgorithm>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptionKey {
    fn default() -> &'a EncryptionKey {
        <EncryptionKey as ::protobuf::Message>::default_instance()
    }
}

impl EncryptionKey {
    pub fn new() -> EncryptionKey {
        ::std::default::Default::default()
    }

    // optional string keyName = 1;


    pub fn get_keyName(&self) -> &str {
        match self.keyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_keyName(&mut self) {
        self.keyName.clear();
    }

    pub fn has_keyName(&self) -> bool {
        self.keyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyName(&mut self, v: ::std::string::String) {
        self.keyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyName(&mut self) -> &mut ::std::string::String {
        if self.keyName.is_none() {
            self.keyName.set_default();
        }
        self.keyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyName(&mut self) -> ::std::string::String {
        self.keyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 keyVersion = 2;


    pub fn get_keyVersion(&self) -> u32 {
        self.keyVersion.unwrap_or(0)
    }
    pub fn clear_keyVersion(&mut self) {
        self.keyVersion = ::std::option::Option::None;
    }

    pub fn has_keyVersion(&self) -> bool {
        self.keyVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyVersion(&mut self, v: u32) {
        self.keyVersion = ::std::option::Option::Some(v);
    }

    // optional .orc.proto.EncryptionAlgorithm algorithm = 3;


    pub fn get_algorithm(&self) -> EncryptionAlgorithm {
        self.algorithm.unwrap_or(EncryptionAlgorithm::UNKNOWN_ENCRYPTION)
    }
    pub fn clear_algorithm(&mut self) {
        self.algorithm = ::std::option::Option::None;
    }

    pub fn has_algorithm(&self) -> bool {
        self.algorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: EncryptionAlgorithm) {
        self.algorithm = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EncryptionKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.keyName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.keyVersion = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.algorithm, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.keyName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.keyVersion {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.algorithm {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.keyName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.keyVersion {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.algorithm {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptionKey {
        EncryptionKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "keyName",
                |m: &EncryptionKey| { &m.keyName },
                |m: &mut EncryptionKey| { &mut m.keyName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "keyVersion",
                |m: &EncryptionKey| { &m.keyVersion },
                |m: &mut EncryptionKey| { &mut m.keyVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncryptionAlgorithm>>(
                "algorithm",
                |m: &EncryptionKey| { &m.algorithm },
                |m: &mut EncryptionKey| { &mut m.algorithm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptionKey>(
                "EncryptionKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptionKey {
        static instance: ::protobuf::rt::LazyV2<EncryptionKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptionKey::new)
    }
}

impl ::protobuf::Clear for EncryptionKey {
    fn clear(&mut self) {
        self.keyName.clear();
        self.keyVersion = ::std::option::Option::None;
        self.algorithm = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptionKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptionKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptionVariant {
    // message fields
    root: ::std::option::Option<u32>,
    key: ::std::option::Option<u32>,
    encryptedKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub stripeStatistics: ::protobuf::RepeatedField<Stream>,
    fileStatistics: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptionVariant {
    fn default() -> &'a EncryptionVariant {
        <EncryptionVariant as ::protobuf::Message>::default_instance()
    }
}

impl EncryptionVariant {
    pub fn new() -> EncryptionVariant {
        ::std::default::Default::default()
    }

    // optional uint32 root = 1;


    pub fn get_root(&self) -> u32 {
        self.root.unwrap_or(0)
    }
    pub fn clear_root(&mut self) {
        self.root = ::std::option::Option::None;
    }

    pub fn has_root(&self) -> bool {
        self.root.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root(&mut self, v: u32) {
        self.root = ::std::option::Option::Some(v);
    }

    // optional uint32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key.unwrap_or(0)
    }
    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = ::std::option::Option::Some(v);
    }

    // optional bytes encryptedKey = 3;


    pub fn get_encryptedKey(&self) -> &[u8] {
        match self.encryptedKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_encryptedKey(&mut self) {
        self.encryptedKey.clear();
    }

    pub fn has_encryptedKey(&self) -> bool {
        self.encryptedKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryptedKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.encryptedKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryptedKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encryptedKey.is_none() {
            self.encryptedKey.set_default();
        }
        self.encryptedKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryptedKey(&mut self) -> ::std::vec::Vec<u8> {
        self.encryptedKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated .orc.proto.Stream stripeStatistics = 4;


    pub fn get_stripeStatistics(&self) -> &[Stream] {
        &self.stripeStatistics
    }
    pub fn clear_stripeStatistics(&mut self) {
        self.stripeStatistics.clear();
    }

    // Param is passed by value, moved
    pub fn set_stripeStatistics(&mut self, v: ::protobuf::RepeatedField<Stream>) {
        self.stripeStatistics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stripeStatistics(&mut self) -> &mut ::protobuf::RepeatedField<Stream> {
        &mut self.stripeStatistics
    }

    // Take field
    pub fn take_stripeStatistics(&mut self) -> ::protobuf::RepeatedField<Stream> {
        ::std::mem::replace(&mut self.stripeStatistics, ::protobuf::RepeatedField::new())
    }

    // optional bytes fileStatistics = 5;


    pub fn get_fileStatistics(&self) -> &[u8] {
        match self.fileStatistics.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_fileStatistics(&mut self) {
        self.fileStatistics.clear();
    }

    pub fn has_fileStatistics(&self) -> bool {
        self.fileStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileStatistics(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileStatistics = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileStatistics(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileStatistics.is_none() {
            self.fileStatistics.set_default();
        }
        self.fileStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileStatistics(&mut self) -> ::std::vec::Vec<u8> {
        self.fileStatistics.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EncryptionVariant {
    fn is_initialized(&self) -> bool {
        for v in &self.stripeStatistics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.root = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.key = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.encryptedKey)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stripeStatistics)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.fileStatistics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.root {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.key {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.encryptedKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        for value in &self.stripeStatistics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.fileStatistics.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.root {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.key {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.encryptedKey.as_ref() {
            os.write_bytes(3, &v)?;
        }
        for v in &self.stripeStatistics {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.fileStatistics.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptionVariant {
        EncryptionVariant::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "root",
                |m: &EncryptionVariant| { &m.root },
                |m: &mut EncryptionVariant| { &mut m.root },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "key",
                |m: &EncryptionVariant| { &m.key },
                |m: &mut EncryptionVariant| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "encryptedKey",
                |m: &EncryptionVariant| { &m.encryptedKey },
                |m: &mut EncryptionVariant| { &mut m.encryptedKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stream>>(
                "stripeStatistics",
                |m: &EncryptionVariant| { &m.stripeStatistics },
                |m: &mut EncryptionVariant| { &mut m.stripeStatistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "fileStatistics",
                |m: &EncryptionVariant| { &m.fileStatistics },
                |m: &mut EncryptionVariant| { &mut m.fileStatistics },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptionVariant>(
                "EncryptionVariant",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptionVariant {
        static instance: ::protobuf::rt::LazyV2<EncryptionVariant> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptionVariant::new)
    }
}

impl ::protobuf::Clear for EncryptionVariant {
    fn clear(&mut self) {
        self.root = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.encryptedKey.clear();
        self.stripeStatistics.clear();
        self.fileStatistics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptionVariant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptionVariant {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Encryption {
    // message fields
    pub mask: ::protobuf::RepeatedField<DataMask>,
    pub key: ::protobuf::RepeatedField<EncryptionKey>,
    pub variants: ::protobuf::RepeatedField<EncryptionVariant>,
    keyProvider: ::std::option::Option<KeyProviderKind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Encryption {
    fn default() -> &'a Encryption {
        <Encryption as ::protobuf::Message>::default_instance()
    }
}

impl Encryption {
    pub fn new() -> Encryption {
        ::std::default::Default::default()
    }

    // repeated .orc.proto.DataMask mask = 1;


    pub fn get_mask(&self) -> &[DataMask] {
        &self.mask
    }
    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: ::protobuf::RepeatedField<DataMask>) {
        self.mask = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mask(&mut self) -> &mut ::protobuf::RepeatedField<DataMask> {
        &mut self.mask
    }

    // Take field
    pub fn take_mask(&mut self) -> ::protobuf::RepeatedField<DataMask> {
        ::std::mem::replace(&mut self.mask, ::protobuf::RepeatedField::new())
    }

    // repeated .orc.proto.EncryptionKey key = 2;


    pub fn get_key(&self) -> &[EncryptionKey] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::protobuf::RepeatedField<EncryptionKey>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    pub fn mut_key(&mut self) -> &mut ::protobuf::RepeatedField<EncryptionKey> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::protobuf::RepeatedField<EncryptionKey> {
        ::std::mem::replace(&mut self.key, ::protobuf::RepeatedField::new())
    }

    // repeated .orc.proto.EncryptionVariant variants = 3;


    pub fn get_variants(&self) -> &[EncryptionVariant] {
        &self.variants
    }
    pub fn clear_variants(&mut self) {
        self.variants.clear();
    }

    // Param is passed by value, moved
    pub fn set_variants(&mut self, v: ::protobuf::RepeatedField<EncryptionVariant>) {
        self.variants = v;
    }

    // Mutable pointer to the field.
    pub fn mut_variants(&mut self) -> &mut ::protobuf::RepeatedField<EncryptionVariant> {
        &mut self.variants
    }

    // Take field
    pub fn take_variants(&mut self) -> ::protobuf::RepeatedField<EncryptionVariant> {
        ::std::mem::replace(&mut self.variants, ::protobuf::RepeatedField::new())
    }

    // optional .orc.proto.KeyProviderKind keyProvider = 4;


    pub fn get_keyProvider(&self) -> KeyProviderKind {
        self.keyProvider.unwrap_or(KeyProviderKind::UNKNOWN)
    }
    pub fn clear_keyProvider(&mut self) {
        self.keyProvider = ::std::option::Option::None;
    }

    pub fn has_keyProvider(&self) -> bool {
        self.keyProvider.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyProvider(&mut self, v: KeyProviderKind) {
        self.keyProvider = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Encryption {
    fn is_initialized(&self) -> bool {
        for v in &self.mask {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.variants {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mask)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.variants)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.keyProvider, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.mask {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.key {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.variants {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.keyProvider {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.mask {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.key {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.variants {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.keyProvider {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Encryption {
        Encryption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMask>>(
                "mask",
                |m: &Encryption| { &m.mask },
                |m: &mut Encryption| { &mut m.mask },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptionKey>>(
                "key",
                |m: &Encryption| { &m.key },
                |m: &mut Encryption| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptionVariant>>(
                "variants",
                |m: &Encryption| { &m.variants },
                |m: &mut Encryption| { &mut m.variants },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<KeyProviderKind>>(
                "keyProvider",
                |m: &Encryption| { &m.keyProvider },
                |m: &mut Encryption| { &mut m.keyProvider },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Encryption>(
                "Encryption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Encryption {
        static instance: ::protobuf::rt::LazyV2<Encryption> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Encryption::new)
    }
}

impl ::protobuf::Clear for Encryption {
    fn clear(&mut self) {
        self.mask.clear();
        self.key.clear();
        self.variants.clear();
        self.keyProvider = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Encryption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Encryption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Footer {
    // message fields
    headerLength: ::std::option::Option<u64>,
    contentLength: ::std::option::Option<u64>,
    pub stripes: ::protobuf::RepeatedField<StripeInformation>,
    pub types: ::protobuf::RepeatedField<Type>,
    pub metadata: ::protobuf::RepeatedField<UserMetadataItem>,
    numberOfRows: ::std::option::Option<u64>,
    pub statistics: ::protobuf::RepeatedField<ColumnStatistics>,
    rowIndexStride: ::std::option::Option<u32>,
    writer: ::std::option::Option<u32>,
    pub encryption: ::protobuf::SingularPtrField<Encryption>,
    calendar: ::std::option::Option<CalendarKind>,
    softwareVersion: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Footer {
    fn default() -> &'a Footer {
        <Footer as ::protobuf::Message>::default_instance()
    }
}

impl Footer {
    pub fn new() -> Footer {
        ::std::default::Default::default()
    }

    // optional uint64 headerLength = 1;


    pub fn get_headerLength(&self) -> u64 {
        self.headerLength.unwrap_or(0)
    }
    pub fn clear_headerLength(&mut self) {
        self.headerLength = ::std::option::Option::None;
    }

    pub fn has_headerLength(&self) -> bool {
        self.headerLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headerLength(&mut self, v: u64) {
        self.headerLength = ::std::option::Option::Some(v);
    }

    // optional uint64 contentLength = 2;


    pub fn get_contentLength(&self) -> u64 {
        self.contentLength.unwrap_or(0)
    }
    pub fn clear_contentLength(&mut self) {
        self.contentLength = ::std::option::Option::None;
    }

    pub fn has_contentLength(&self) -> bool {
        self.contentLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contentLength(&mut self, v: u64) {
        self.contentLength = ::std::option::Option::Some(v);
    }

    // repeated .orc.proto.StripeInformation stripes = 3;


    pub fn get_stripes(&self) -> &[StripeInformation] {
        &self.stripes
    }
    pub fn clear_stripes(&mut self) {
        self.stripes.clear();
    }

    // Param is passed by value, moved
    pub fn set_stripes(&mut self, v: ::protobuf::RepeatedField<StripeInformation>) {
        self.stripes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stripes(&mut self) -> &mut ::protobuf::RepeatedField<StripeInformation> {
        &mut self.stripes
    }

    // Take field
    pub fn take_stripes(&mut self) -> ::protobuf::RepeatedField<StripeInformation> {
        ::std::mem::replace(&mut self.stripes, ::protobuf::RepeatedField::new())
    }

    // repeated .orc.proto.Type types = 4;


    pub fn get_types(&self) -> &[Type] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.types, ::protobuf::RepeatedField::new())
    }

    // repeated .orc.proto.UserMetadataItem metadata = 5;


    pub fn get_metadata(&self) -> &[UserMetadataItem] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::RepeatedField<UserMetadataItem>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::RepeatedField<UserMetadataItem> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::RepeatedField<UserMetadataItem> {
        ::std::mem::replace(&mut self.metadata, ::protobuf::RepeatedField::new())
    }

    // optional uint64 numberOfRows = 6;


    pub fn get_numberOfRows(&self) -> u64 {
        self.numberOfRows.unwrap_or(0)
    }
    pub fn clear_numberOfRows(&mut self) {
        self.numberOfRows = ::std::option::Option::None;
    }

    pub fn has_numberOfRows(&self) -> bool {
        self.numberOfRows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberOfRows(&mut self, v: u64) {
        self.numberOfRows = ::std::option::Option::Some(v);
    }

    // repeated .orc.proto.ColumnStatistics statistics = 7;


    pub fn get_statistics(&self) -> &[ColumnStatistics] {
        &self.statistics
    }
    pub fn clear_statistics(&mut self) {
        self.statistics.clear();
    }

    // Param is passed by value, moved
    pub fn set_statistics(&mut self, v: ::protobuf::RepeatedField<ColumnStatistics>) {
        self.statistics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statistics(&mut self) -> &mut ::protobuf::RepeatedField<ColumnStatistics> {
        &mut self.statistics
    }

    // Take field
    pub fn take_statistics(&mut self) -> ::protobuf::RepeatedField<ColumnStatistics> {
        ::std::mem::replace(&mut self.statistics, ::protobuf::RepeatedField::new())
    }

    // optional uint32 rowIndexStride = 8;


    pub fn get_rowIndexStride(&self) -> u32 {
        self.rowIndexStride.unwrap_or(0)
    }
    pub fn clear_rowIndexStride(&mut self) {
        self.rowIndexStride = ::std::option::Option::None;
    }

    pub fn has_rowIndexStride(&self) -> bool {
        self.rowIndexStride.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rowIndexStride(&mut self, v: u32) {
        self.rowIndexStride = ::std::option::Option::Some(v);
    }

    // optional uint32 writer = 9;


    pub fn get_writer(&self) -> u32 {
        self.writer.unwrap_or(0)
    }
    pub fn clear_writer(&mut self) {
        self.writer = ::std::option::Option::None;
    }

    pub fn has_writer(&self) -> bool {
        self.writer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writer(&mut self, v: u32) {
        self.writer = ::std::option::Option::Some(v);
    }

    // optional .orc.proto.Encryption encryption = 10;


    pub fn get_encryption(&self) -> &Encryption {
        self.encryption.as_ref().unwrap_or_else(|| <Encryption as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encryption(&mut self) {
        self.encryption.clear();
    }

    pub fn has_encryption(&self) -> bool {
        self.encryption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption(&mut self, v: Encryption) {
        self.encryption = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption(&mut self) -> &mut Encryption {
        if self.encryption.is_none() {
            self.encryption.set_default();
        }
        self.encryption.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption(&mut self) -> Encryption {
        self.encryption.take().unwrap_or_else(|| Encryption::new())
    }

    // optional .orc.proto.CalendarKind calendar = 11;


    pub fn get_calendar(&self) -> CalendarKind {
        self.calendar.unwrap_or(CalendarKind::UNKNOWN_CALENDAR)
    }
    pub fn clear_calendar(&mut self) {
        self.calendar = ::std::option::Option::None;
    }

    pub fn has_calendar(&self) -> bool {
        self.calendar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_calendar(&mut self, v: CalendarKind) {
        self.calendar = ::std::option::Option::Some(v);
    }

    // optional string softwareVersion = 12;


    pub fn get_softwareVersion(&self) -> &str {
        match self.softwareVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_softwareVersion(&mut self) {
        self.softwareVersion.clear();
    }

    pub fn has_softwareVersion(&self) -> bool {
        self.softwareVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_softwareVersion(&mut self, v: ::std::string::String) {
        self.softwareVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_softwareVersion(&mut self) -> &mut ::std::string::String {
        if self.softwareVersion.is_none() {
            self.softwareVersion.set_default();
        }
        self.softwareVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_softwareVersion(&mut self) -> ::std::string::String {
        self.softwareVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Footer {
    fn is_initialized(&self) -> bool {
        for v in &self.stripes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.types {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryption {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.headerLength = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.contentLength = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stripes)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.types)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.numberOfRows = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statistics)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rowIndexStride = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.writer = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryption)?;
                },
                11 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.calendar, 11, &mut self.unknown_fields)?
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.softwareVersion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.headerLength {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.contentLength {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stripes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.numberOfRows {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.statistics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.rowIndexStride {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.writer {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.encryption.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.calendar {
            my_size += ::protobuf::rt::enum_size(11, v);
        }
        if let Some(ref v) = self.softwareVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.headerLength {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.contentLength {
            os.write_uint64(2, v)?;
        }
        for v in &self.stripes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.types {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.metadata {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.numberOfRows {
            os.write_uint64(6, v)?;
        }
        for v in &self.statistics {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.rowIndexStride {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.writer {
            os.write_uint32(9, v)?;
        }
        if let Some(ref v) = self.encryption.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.calendar {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.softwareVersion.as_ref() {
            os.write_string(12, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Footer {
        Footer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "headerLength",
                |m: &Footer| { &m.headerLength },
                |m: &mut Footer| { &mut m.headerLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "contentLength",
                |m: &Footer| { &m.contentLength },
                |m: &mut Footer| { &mut m.contentLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StripeInformation>>(
                "stripes",
                |m: &Footer| { &m.stripes },
                |m: &mut Footer| { &mut m.stripes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                "types",
                |m: &Footer| { &m.types },
                |m: &mut Footer| { &mut m.types },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserMetadataItem>>(
                "metadata",
                |m: &Footer| { &m.metadata },
                |m: &mut Footer| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "numberOfRows",
                |m: &Footer| { &m.numberOfRows },
                |m: &mut Footer| { &mut m.numberOfRows },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColumnStatistics>>(
                "statistics",
                |m: &Footer| { &m.statistics },
                |m: &mut Footer| { &mut m.statistics },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rowIndexStride",
                |m: &Footer| { &m.rowIndexStride },
                |m: &mut Footer| { &mut m.rowIndexStride },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "writer",
                |m: &Footer| { &m.writer },
                |m: &mut Footer| { &mut m.writer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Encryption>>(
                "encryption",
                |m: &Footer| { &m.encryption },
                |m: &mut Footer| { &mut m.encryption },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CalendarKind>>(
                "calendar",
                |m: &Footer| { &m.calendar },
                |m: &mut Footer| { &mut m.calendar },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "softwareVersion",
                |m: &Footer| { &m.softwareVersion },
                |m: &mut Footer| { &mut m.softwareVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Footer>(
                "Footer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Footer {
        static instance: ::protobuf::rt::LazyV2<Footer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Footer::new)
    }
}

impl ::protobuf::Clear for Footer {
    fn clear(&mut self) {
        self.headerLength = ::std::option::Option::None;
        self.contentLength = ::std::option::Option::None;
        self.stripes.clear();
        self.types.clear();
        self.metadata.clear();
        self.numberOfRows = ::std::option::Option::None;
        self.statistics.clear();
        self.rowIndexStride = ::std::option::Option::None;
        self.writer = ::std::option::Option::None;
        self.encryption.clear();
        self.calendar = ::std::option::Option::None;
        self.softwareVersion.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Footer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Footer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostScript {
    // message fields
    footerLength: ::std::option::Option<u64>,
    compression: ::std::option::Option<CompressionKind>,
    compressionBlockSize: ::std::option::Option<u64>,
    pub version: ::std::vec::Vec<u32>,
    metadataLength: ::std::option::Option<u64>,
    writerVersion: ::std::option::Option<u32>,
    stripeStatisticsLength: ::std::option::Option<u64>,
    magic: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostScript {
    fn default() -> &'a PostScript {
        <PostScript as ::protobuf::Message>::default_instance()
    }
}

impl PostScript {
    pub fn new() -> PostScript {
        ::std::default::Default::default()
    }

    // optional uint64 footerLength = 1;


    pub fn get_footerLength(&self) -> u64 {
        self.footerLength.unwrap_or(0)
    }
    pub fn clear_footerLength(&mut self) {
        self.footerLength = ::std::option::Option::None;
    }

    pub fn has_footerLength(&self) -> bool {
        self.footerLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_footerLength(&mut self, v: u64) {
        self.footerLength = ::std::option::Option::Some(v);
    }

    // optional .orc.proto.CompressionKind compression = 2;


    pub fn get_compression(&self) -> CompressionKind {
        self.compression.unwrap_or(CompressionKind::NONE)
    }
    pub fn clear_compression(&mut self) {
        self.compression = ::std::option::Option::None;
    }

    pub fn has_compression(&self) -> bool {
        self.compression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compression(&mut self, v: CompressionKind) {
        self.compression = ::std::option::Option::Some(v);
    }

    // optional uint64 compressionBlockSize = 3;


    pub fn get_compressionBlockSize(&self) -> u64 {
        self.compressionBlockSize.unwrap_or(0)
    }
    pub fn clear_compressionBlockSize(&mut self) {
        self.compressionBlockSize = ::std::option::Option::None;
    }

    pub fn has_compressionBlockSize(&self) -> bool {
        self.compressionBlockSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compressionBlockSize(&mut self, v: u64) {
        self.compressionBlockSize = ::std::option::Option::Some(v);
    }

    // repeated uint32 version = 4;


    pub fn get_version(&self) -> &[u32] {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::vec::Vec<u32>) {
        self.version = v;
    }

    // Mutable pointer to the field.
    pub fn mut_version(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.version, ::std::vec::Vec::new())
    }

    // optional uint64 metadataLength = 5;


    pub fn get_metadataLength(&self) -> u64 {
        self.metadataLength.unwrap_or(0)
    }
    pub fn clear_metadataLength(&mut self) {
        self.metadataLength = ::std::option::Option::None;
    }

    pub fn has_metadataLength(&self) -> bool {
        self.metadataLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadataLength(&mut self, v: u64) {
        self.metadataLength = ::std::option::Option::Some(v);
    }

    // optional uint32 writerVersion = 6;


    pub fn get_writerVersion(&self) -> u32 {
        self.writerVersion.unwrap_or(0)
    }
    pub fn clear_writerVersion(&mut self) {
        self.writerVersion = ::std::option::Option::None;
    }

    pub fn has_writerVersion(&self) -> bool {
        self.writerVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writerVersion(&mut self, v: u32) {
        self.writerVersion = ::std::option::Option::Some(v);
    }

    // optional uint64 stripeStatisticsLength = 7;


    pub fn get_stripeStatisticsLength(&self) -> u64 {
        self.stripeStatisticsLength.unwrap_or(0)
    }
    pub fn clear_stripeStatisticsLength(&mut self) {
        self.stripeStatisticsLength = ::std::option::Option::None;
    }

    pub fn has_stripeStatisticsLength(&self) -> bool {
        self.stripeStatisticsLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stripeStatisticsLength(&mut self, v: u64) {
        self.stripeStatisticsLength = ::std::option::Option::Some(v);
    }

    // optional string magic = 8000;


    pub fn get_magic(&self) -> &str {
        match self.magic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_magic(&mut self) {
        self.magic.clear();
    }

    pub fn has_magic(&self) -> bool {
        self.magic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magic(&mut self, v: ::std::string::String) {
        self.magic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_magic(&mut self) -> &mut ::std::string::String {
        if self.magic.is_none() {
            self.magic.set_default();
        }
        self.magic.as_mut().unwrap()
    }

    // Take field
    pub fn take_magic(&mut self) -> ::std::string::String {
        self.magic.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PostScript {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.footerLength = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.compression, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.compressionBlockSize = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.version)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.metadataLength = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.writerVersion = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.stripeStatisticsLength = ::std::option::Option::Some(tmp);
                },
                8000 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.magic)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.footerLength {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.compression {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.compressionBlockSize {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(4, &self.version);
        }
        if let Some(v) = self.metadataLength {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.writerVersion {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stripeStatisticsLength {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.magic.as_ref() {
            my_size += ::protobuf::rt::string_size(8000, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.footerLength {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.compression {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.compressionBlockSize {
            os.write_uint64(3, v)?;
        }
        if !self.version.is_empty() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.version))?;
            for v in &self.version {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if let Some(v) = self.metadataLength {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.writerVersion {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.stripeStatisticsLength {
            os.write_uint64(7, v)?;
        }
        if let Some(ref v) = self.magic.as_ref() {
            os.write_string(8000, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostScript {
        PostScript::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "footerLength",
                |m: &PostScript| { &m.footerLength },
                |m: &mut PostScript| { &mut m.footerLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CompressionKind>>(
                "compression",
                |m: &PostScript| { &m.compression },
                |m: &mut PostScript| { &mut m.compression },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "compressionBlockSize",
                |m: &PostScript| { &m.compressionBlockSize },
                |m: &mut PostScript| { &mut m.compressionBlockSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &PostScript| { &m.version },
                |m: &mut PostScript| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "metadataLength",
                |m: &PostScript| { &m.metadataLength },
                |m: &mut PostScript| { &mut m.metadataLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "writerVersion",
                |m: &PostScript| { &m.writerVersion },
                |m: &mut PostScript| { &mut m.writerVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "stripeStatisticsLength",
                |m: &PostScript| { &m.stripeStatisticsLength },
                |m: &mut PostScript| { &mut m.stripeStatisticsLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "magic",
                |m: &PostScript| { &m.magic },
                |m: &mut PostScript| { &mut m.magic },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostScript>(
                "PostScript",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostScript {
        static instance: ::protobuf::rt::LazyV2<PostScript> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostScript::new)
    }
}

impl ::protobuf::Clear for PostScript {
    fn clear(&mut self) {
        self.footerLength = ::std::option::Option::None;
        self.compression = ::std::option::Option::None;
        self.compressionBlockSize = ::std::option::Option::None;
        self.version.clear();
        self.metadataLength = ::std::option::Option::None;
        self.writerVersion = ::std::option::Option::None;
        self.stripeStatisticsLength = ::std::option::Option::None;
        self.magic.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostScript {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostScript {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileTail {
    // message fields
    pub postscript: ::protobuf::SingularPtrField<PostScript>,
    pub footer: ::protobuf::SingularPtrField<Footer>,
    fileLength: ::std::option::Option<u64>,
    postscriptLength: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileTail {
    fn default() -> &'a FileTail {
        <FileTail as ::protobuf::Message>::default_instance()
    }
}

impl FileTail {
    pub fn new() -> FileTail {
        ::std::default::Default::default()
    }

    // optional .orc.proto.PostScript postscript = 1;


    pub fn get_postscript(&self) -> &PostScript {
        self.postscript.as_ref().unwrap_or_else(|| <PostScript as ::protobuf::Message>::default_instance())
    }
    pub fn clear_postscript(&mut self) {
        self.postscript.clear();
    }

    pub fn has_postscript(&self) -> bool {
        self.postscript.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postscript(&mut self, v: PostScript) {
        self.postscript = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postscript(&mut self) -> &mut PostScript {
        if self.postscript.is_none() {
            self.postscript.set_default();
        }
        self.postscript.as_mut().unwrap()
    }

    // Take field
    pub fn take_postscript(&mut self) -> PostScript {
        self.postscript.take().unwrap_or_else(|| PostScript::new())
    }

    // optional .orc.proto.Footer footer = 2;


    pub fn get_footer(&self) -> &Footer {
        self.footer.as_ref().unwrap_or_else(|| <Footer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_footer(&mut self) {
        self.footer.clear();
    }

    pub fn has_footer(&self) -> bool {
        self.footer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_footer(&mut self, v: Footer) {
        self.footer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_footer(&mut self) -> &mut Footer {
        if self.footer.is_none() {
            self.footer.set_default();
        }
        self.footer.as_mut().unwrap()
    }

    // Take field
    pub fn take_footer(&mut self) -> Footer {
        self.footer.take().unwrap_or_else(|| Footer::new())
    }

    // optional uint64 fileLength = 3;


    pub fn get_fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }
    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional uint64 postscriptLength = 4;


    pub fn get_postscriptLength(&self) -> u64 {
        self.postscriptLength.unwrap_or(0)
    }
    pub fn clear_postscriptLength(&mut self) {
        self.postscriptLength = ::std::option::Option::None;
    }

    pub fn has_postscriptLength(&self) -> bool {
        self.postscriptLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postscriptLength(&mut self, v: u64) {
        self.postscriptLength = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FileTail {
    fn is_initialized(&self) -> bool {
        for v in &self.postscript {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.footer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postscript)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.footer)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileLength = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.postscriptLength = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.postscript.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.footer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.postscriptLength {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.postscript.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.footer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.postscriptLength {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileTail {
        FileTail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PostScript>>(
                "postscript",
                |m: &FileTail| { &m.postscript },
                |m: &mut FileTail| { &mut m.postscript },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Footer>>(
                "footer",
                |m: &FileTail| { &m.footer },
                |m: &mut FileTail| { &mut m.footer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fileLength",
                |m: &FileTail| { &m.fileLength },
                |m: &mut FileTail| { &mut m.fileLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "postscriptLength",
                |m: &FileTail| { &m.postscriptLength },
                |m: &mut FileTail| { &mut m.postscriptLength },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileTail>(
                "FileTail",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileTail {
        static instance: ::protobuf::rt::LazyV2<FileTail> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileTail::new)
    }
}

impl ::protobuf::Clear for FileTail {
    fn clear(&mut self) {
        self.postscript.clear();
        self.footer.clear();
        self.fileLength = ::std::option::Option::None;
        self.postscriptLength = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileTail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTail {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EncryptionAlgorithm {
    UNKNOWN_ENCRYPTION = 0,
    AES_CTR_128 = 1,
    AES_CTR_256 = 2,
}

impl ::protobuf::ProtobufEnum for EncryptionAlgorithm {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EncryptionAlgorithm> {
        match value {
            0 => ::std::option::Option::Some(EncryptionAlgorithm::UNKNOWN_ENCRYPTION),
            1 => ::std::option::Option::Some(EncryptionAlgorithm::AES_CTR_128),
            2 => ::std::option::Option::Some(EncryptionAlgorithm::AES_CTR_256),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EncryptionAlgorithm] = &[
            EncryptionAlgorithm::UNKNOWN_ENCRYPTION,
            EncryptionAlgorithm::AES_CTR_128,
            EncryptionAlgorithm::AES_CTR_256,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EncryptionAlgorithm>("EncryptionAlgorithm", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EncryptionAlgorithm {
}

impl ::std::default::Default for EncryptionAlgorithm {
    fn default() -> Self {
        EncryptionAlgorithm::UNKNOWN_ENCRYPTION
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptionAlgorithm {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum KeyProviderKind {
    UNKNOWN = 0,
    HADOOP = 1,
    AWS = 2,
    GCP = 3,
    AZURE = 4,
}

impl ::protobuf::ProtobufEnum for KeyProviderKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KeyProviderKind> {
        match value {
            0 => ::std::option::Option::Some(KeyProviderKind::UNKNOWN),
            1 => ::std::option::Option::Some(KeyProviderKind::HADOOP),
            2 => ::std::option::Option::Some(KeyProviderKind::AWS),
            3 => ::std::option::Option::Some(KeyProviderKind::GCP),
            4 => ::std::option::Option::Some(KeyProviderKind::AZURE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [KeyProviderKind] = &[
            KeyProviderKind::UNKNOWN,
            KeyProviderKind::HADOOP,
            KeyProviderKind::AWS,
            KeyProviderKind::GCP,
            KeyProviderKind::AZURE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<KeyProviderKind>("KeyProviderKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for KeyProviderKind {
}

impl ::std::default::Default for KeyProviderKind {
    fn default() -> Self {
        KeyProviderKind::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyProviderKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CalendarKind {
    UNKNOWN_CALENDAR = 0,
    JULIAN_GREGORIAN = 1,
    PROLEPTIC_GREGORIAN = 2,
}

impl ::protobuf::ProtobufEnum for CalendarKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CalendarKind> {
        match value {
            0 => ::std::option::Option::Some(CalendarKind::UNKNOWN_CALENDAR),
            1 => ::std::option::Option::Some(CalendarKind::JULIAN_GREGORIAN),
            2 => ::std::option::Option::Some(CalendarKind::PROLEPTIC_GREGORIAN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CalendarKind] = &[
            CalendarKind::UNKNOWN_CALENDAR,
            CalendarKind::JULIAN_GREGORIAN,
            CalendarKind::PROLEPTIC_GREGORIAN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CalendarKind>("CalendarKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CalendarKind {
}

impl ::std::default::Default for CalendarKind {
    fn default() -> Self {
        CalendarKind::UNKNOWN_CALENDAR
    }
}

impl ::protobuf::reflect::ProtobufValue for CalendarKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CompressionKind {
    NONE = 0,
    ZLIB = 1,
    SNAPPY = 2,
    LZO = 3,
    LZ4 = 4,
    ZSTD = 5,
}

impl ::protobuf::ProtobufEnum for CompressionKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CompressionKind> {
        match value {
            0 => ::std::option::Option::Some(CompressionKind::NONE),
            1 => ::std::option::Option::Some(CompressionKind::ZLIB),
            2 => ::std::option::Option::Some(CompressionKind::SNAPPY),
            3 => ::std::option::Option::Some(CompressionKind::LZO),
            4 => ::std::option::Option::Some(CompressionKind::LZ4),
            5 => ::std::option::Option::Some(CompressionKind::ZSTD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CompressionKind] = &[
            CompressionKind::NONE,
            CompressionKind::ZLIB,
            CompressionKind::SNAPPY,
            CompressionKind::LZO,
            CompressionKind::LZ4,
            CompressionKind::ZSTD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CompressionKind>("CompressionKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CompressionKind {
}

impl ::std::default::Default for CompressionKind {
    fn default() -> Self {
        CompressionKind::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for CompressionKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0forc_proto.proto\x12\torc.proto\"a\n\x11IntegerStatistics\x12\x1a\n\
    \x07minimum\x18\x01\x20\x01(\x12R\x07minimumB\0\x12\x1a\n\x07maximum\x18\
    \x02\x20\x01(\x12R\x07maximumB\0\x12\x12\n\x03sum\x18\x03\x20\x01(\x12R\
    \x03sumB\0:\0\"`\n\x10DoubleStatistics\x12\x1a\n\x07minimum\x18\x01\x20\
    \x01(\x01R\x07minimumB\0\x12\x1a\n\x07maximum\x18\x02\x20\x01(\x01R\x07m\
    aximumB\0\x12\x12\n\x03sum\x18\x03\x20\x01(\x01R\x03sumB\0:\0\"\xa4\x01\
    \n\x10StringStatistics\x12\x1a\n\x07minimum\x18\x01\x20\x01(\tR\x07minim\
    umB\0\x12\x1a\n\x07maximum\x18\x02\x20\x01(\tR\x07maximumB\0\x12\x12\n\
    \x03sum\x18\x03\x20\x01(\x12R\x03sumB\0\x12\x20\n\nlowerBound\x18\x04\
    \x20\x01(\tR\nlowerBoundB\0\x12\x20\n\nupperBound\x18\x05\x20\x01(\tR\nu\
    pperBoundB\0:\0\".\n\x10BucketStatistics\x12\x18\n\x05count\x18\x01\x20\
    \x03(\x04R\x05countB\x02\x10\x01:\0\"a\n\x11DecimalStatistics\x12\x1a\n\
    \x07minimum\x18\x01\x20\x01(\tR\x07minimumB\0\x12\x1a\n\x07maximum\x18\
    \x02\x20\x01(\tR\x07maximumB\0\x12\x12\n\x03sum\x18\x03\x20\x01(\tR\x03s\
    umB\0:\0\"J\n\x0eDateStatistics\x12\x1a\n\x07minimum\x18\x01\x20\x01(\
    \x11R\x07minimumB\0\x12\x1a\n\x07maximum\x18\x02\x20\x01(\x11R\x07maximu\
    mB\0:\0\"\xdf\x01\n\x13TimestampStatistics\x12\x1a\n\x07minimum\x18\x01\
    \x20\x01(\x12R\x07minimumB\0\x12\x1a\n\x07maximum\x18\x02\x20\x01(\x12R\
    \x07maximumB\0\x12\x20\n\nminimumUtc\x18\x03\x20\x01(\x12R\nminimumUtcB\
    \0\x12\x20\n\nmaximumUtc\x18\x04\x20\x01(\x12R\nmaximumUtcB\0\x12$\n\x0c\
    minimumNanos\x18\x05\x20\x01(\x05R\x0cminimumNanosB\0\x12$\n\x0cmaximumN\
    anos\x18\x06\x20\x01(\x05R\x0cmaximumNanosB\0:\0\"(\n\x10BinaryStatistic\
    s\x12\x12\n\x03sum\x18\x01\x20\x01(\x12R\x03sumB\0:\0\"\x88\x01\n\x14Col\
    lectionStatistics\x12\"\n\x0bminChildren\x18\x01\x20\x01(\x04R\x0bminChi\
    ldrenB\0\x12\"\n\x0bmaxChildren\x18\x02\x20\x01(\x04R\x0bmaxChildrenB\0\
    \x12&\n\rtotalChildren\x18\x03\x20\x01(\x04R\rtotalChildrenB\0:\0\"\xae\
    \x06\n\x10ColumnStatistics\x12(\n\x0enumberOfValues\x18\x01\x20\x01(\x04\
    R\x0enumberOfValuesB\0\x12D\n\rintStatistics\x18\x02\x20\x01(\x0b2\x1c.o\
    rc.proto.IntegerStatisticsR\rintStatisticsB\0\x12I\n\x10doubleStatistics\
    \x18\x03\x20\x01(\x0b2\x1b.orc.proto.DoubleStatisticsR\x10doubleStatisti\
    csB\0\x12I\n\x10stringStatistics\x18\x04\x20\x01(\x0b2\x1b.orc.proto.Str\
    ingStatisticsR\x10stringStatisticsB\0\x12I\n\x10bucketStatistics\x18\x05\
    \x20\x01(\x0b2\x1b.orc.proto.BucketStatisticsR\x10bucketStatisticsB\0\
    \x12L\n\x11decimalStatistics\x18\x06\x20\x01(\x0b2\x1c.orc.proto.Decimal\
    StatisticsR\x11decimalStatisticsB\0\x12C\n\x0edateStatistics\x18\x07\x20\
    \x01(\x0b2\x19.orc.proto.DateStatisticsR\x0edateStatisticsB\0\x12I\n\x10\
    binaryStatistics\x18\x08\x20\x01(\x0b2\x1b.orc.proto.BinaryStatisticsR\
    \x10binaryStatisticsB\0\x12R\n\x13timestampStatistics\x18\t\x20\x01(\x0b\
    2\x1e.orc.proto.TimestampStatisticsR\x13timestampStatisticsB\0\x12\x1a\n\
    \x07hasNull\x18\n\x20\x01(\x08R\x07hasNullB\0\x12\"\n\x0bbytesOnDisk\x18\
    \x0b\x20\x01(\x04R\x0bbytesOnDiskB\0\x12U\n\x14collectionStatistics\x18\
    \x0c\x20\x01(\x0b2\x1f.orc.proto.CollectionStatisticsR\x14collectionStat\
    isticsB\0:\0\"r\n\rRowIndexEntry\x12\x20\n\tpositions\x18\x01\x20\x03(\
    \x04R\tpositionsB\x02\x10\x01\x12=\n\nstatistics\x18\x02\x20\x01(\x0b2\
    \x1b.orc.proto.ColumnStatisticsR\nstatisticsB\0:\0\">\n\x08RowIndex\x120\
    \n\x05entry\x18\x01\x20\x03(\x0b2\x18.orc.proto.RowIndexEntryR\x05entryB\
    \0:\0\"y\n\x0bBloomFilter\x12,\n\x10numHashFunctions\x18\x01\x20\x01(\rR\
    \x10numHashFunctionsB\0\x12\x18\n\x06bitset\x18\x02\x20\x03(\x06R\x06bit\
    setB\0\x12\x20\n\nutf8bitset\x18\x03\x20\x01(\x0cR\nutf8bitsetB\0:\0\"P\
    \n\x10BloomFilterIndex\x12:\n\x0bbloomFilter\x18\x01\x20\x03(\x0b2\x16.o\
    rc.proto.BloomFilterR\x0bbloomFilterB\0:\0\"\xe1\x02\n\x06Stream\x12,\n\
    \x04kind\x18\x01\x20\x01(\x0e2\x16.orc.proto.Stream.KindR\x04kindB\0\x12\
    \x18\n\x06column\x18\x02\x20\x01(\rR\x06columnB\0\x12\x18\n\x06length\
    \x18\x03\x20\x01(\x04R\x06lengthB\0\"\xf2\x01\n\x04Kind\x12\x0b\n\x07PRE\
    SENT\x10\0\x12\x08\n\x04DATA\x10\x01\x12\n\n\x06LENGTH\x10\x02\x12\x13\n\
    \x0fDICTIONARY_DATA\x10\x03\x12\x14\n\x10DICTIONARY_COUNT\x10\x04\x12\r\
    \n\tSECONDARY\x10\x05\x12\r\n\tROW_INDEX\x10\x06\x12\x10\n\x0cBLOOM_FILT\
    ER\x10\x07\x12\x15\n\x11BLOOM_FILTER_UTF8\x10\x08\x12\x13\n\x0fENCRYPTED\
    _INDEX\x10\t\x12\x12\n\x0eENCRYPTED_DATA\x10\n\x12\x15\n\x11STRIPE_STATI\
    STICS\x10d\x12\x13\n\x0fFILE_STATISTICS\x10e\x1a\0:\0\"\xe2\x01\n\x0eCol\
    umnEncoding\x124\n\x04kind\x18\x01\x20\x01(\x0e2\x1e.orc.proto.ColumnEnc\
    oding.KindR\x04kindB\0\x12(\n\x0edictionarySize\x18\x02\x20\x01(\rR\x0ed\
    ictionarySizeB\0\x12&\n\rbloomEncoding\x18\x03\x20\x01(\rR\rbloomEncodin\
    gB\0\"F\n\x04Kind\x12\n\n\x06DIRECT\x10\0\x12\x0e\n\nDICTIONARY\x10\x01\
    \x12\r\n\tDIRECT_V2\x10\x02\x12\x11\n\rDICTIONARY_V2\x10\x03\x1a\0:\0\"\
    \x83\x01\n\x17StripeEncryptionVariant\x12-\n\x07streams\x18\x01\x20\x03(\
    \x0b2\x11.orc.proto.StreamR\x07streamsB\0\x127\n\x08encoding\x18\x02\x20\
    \x03(\x0b2\x19.orc.proto.ColumnEncodingR\x08encodingB\0:\0\"\xe6\x01\n\
    \x0cStripeFooter\x12-\n\x07streams\x18\x01\x20\x03(\x0b2\x11.orc.proto.S\
    treamR\x07streamsB\0\x125\n\x07columns\x18\x02\x20\x03(\x0b2\x19.orc.pro\
    to.ColumnEncodingR\x07columnsB\0\x12(\n\x0ewriterTimezone\x18\x03\x20\
    \x01(\tR\x0ewriterTimezoneB\0\x12D\n\nencryption\x18\x04\x20\x03(\x0b2\"\
    .orc.proto.StripeEncryptionVariantR\nencryptionB\0:\0\":\n\nStringPair\
    \x12\x12\n\x03key\x18\x01\x20\x01(\tR\x03keyB\0\x12\x16\n\x05value\x18\
    \x02\x20\x01(\tR\x05valueB\0:\0\"\xfc\x03\n\x04Type\x12*\n\x04kind\x18\
    \x01\x20\x01(\x0e2\x14.orc.proto.Type.KindR\x04kindB\0\x12\x1e\n\x08subt\
    ypes\x18\x02\x20\x03(\rR\x08subtypesB\x02\x10\x01\x12\x20\n\nfieldNames\
    \x18\x03\x20\x03(\tR\nfieldNamesB\0\x12&\n\rmaximumLength\x18\x04\x20\
    \x01(\rR\rmaximumLengthB\0\x12\x1e\n\tprecision\x18\x05\x20\x01(\rR\tpre\
    cisionB\0\x12\x16\n\x05scale\x18\x06\x20\x01(\rR\x05scaleB\0\x127\n\natt\
    ributes\x18\x07\x20\x03(\x0b2\x15.orc.proto.StringPairR\nattributesB\0\"\
    \xea\x01\n\x04Kind\x12\x0b\n\x07BOOLEAN\x10\0\x12\x08\n\x04BYTE\x10\x01\
    \x12\t\n\x05SHORT\x10\x02\x12\x07\n\x03INT\x10\x03\x12\x08\n\x04LONG\x10\
    \x04\x12\t\n\x05FLOAT\x10\x05\x12\n\n\x06DOUBLE\x10\x06\x12\n\n\x06STRIN\
    G\x10\x07\x12\n\n\x06BINARY\x10\x08\x12\r\n\tTIMESTAMP\x10\t\x12\x08\n\
    \x04LIST\x10\n\x12\x07\n\x03MAP\x10\x0b\x12\n\n\x06STRUCT\x10\x0c\x12\t\
    \n\x05UNION\x10\r\x12\x0b\n\x07DECIMAL\x10\x0e\x12\x08\n\x04DATE\x10\x0f\
    \x12\x0b\n\x07VARCHAR\x10\x10\x12\x08\n\x04CHAR\x10\x11\x12\x15\n\x11TIM\
    ESTAMP_INSTANT\x10\x12\x1a\0:\0\"\x9f\x02\n\x11StripeInformation\x12\x18\
    \n\x06offset\x18\x01\x20\x01(\x04R\x06offsetB\0\x12\"\n\x0bindexLength\
    \x18\x02\x20\x01(\x04R\x0bindexLengthB\0\x12\x20\n\ndataLength\x18\x03\
    \x20\x01(\x04R\ndataLengthB\0\x12$\n\x0cfooterLength\x18\x04\x20\x01(\
    \x04R\x0cfooterLengthB\0\x12$\n\x0cnumberOfRows\x18\x05\x20\x01(\x04R\
    \x0cnumberOfRowsB\0\x12*\n\x0fencryptStripeId\x18\x06\x20\x01(\x04R\x0fe\
    ncryptStripeIdB\0\x120\n\x12encryptedLocalKeys\x18\x07\x20\x03(\x0cR\x12\
    encryptedLocalKeysB\0:\0\"B\n\x10UserMetadataItem\x12\x14\n\x04name\x18\
    \x01\x20\x01(\tR\x04nameB\0\x12\x16\n\x05value\x18\x02\x20\x01(\x0cR\x05\
    valueB\0:\0\"O\n\x10StripeStatistics\x129\n\x08colStats\x18\x01\x20\x03(\
    \x0b2\x1b.orc.proto.ColumnStatisticsR\x08colStatsB\0:\0\"M\n\x08Metadata\
    \x12?\n\x0bstripeStats\x18\x01\x20\x03(\x0b2\x1b.orc.proto.StripeStatist\
    icsR\x0bstripeStatsB\0:\0\"W\n\x18ColumnarStripeStatistics\x129\n\x08col\
    Stats\x18\x01\x20\x03(\x0b2\x1b.orc.proto.ColumnStatisticsR\x08colStatsB\
    \0:\0\"I\n\x0eFileStatistics\x125\n\x06column\x18\x01\x20\x03(\x0b2\x1b.\
    orc.proto.ColumnStatisticsR\x06columnB\0:\0\"j\n\x08DataMask\x12\x14\n\
    \x04name\x18\x01\x20\x01(\tR\x04nameB\0\x12(\n\x0emaskParameters\x18\x02\
    \x20\x03(\tR\x0emaskParametersB\0\x12\x1c\n\x07columns\x18\x03\x20\x03(\
    \rR\x07columnsB\x02\x10\x01:\0\"\x8f\x01\n\rEncryptionKey\x12\x1a\n\x07k\
    eyName\x18\x01\x20\x01(\tR\x07keyNameB\0\x12\x20\n\nkeyVersion\x18\x02\
    \x20\x01(\rR\nkeyVersionB\0\x12>\n\talgorithm\x18\x03\x20\x01(\x0e2\x1e.\
    orc.proto.EncryptionAlgorithmR\talgorithmB\0:\0\"\xd0\x01\n\x11Encryptio\
    nVariant\x12\x14\n\x04root\x18\x01\x20\x01(\rR\x04rootB\0\x12\x12\n\x03k\
    ey\x18\x02\x20\x01(\rR\x03keyB\0\x12$\n\x0cencryptedKey\x18\x03\x20\x01(\
    \x0cR\x0cencryptedKeyB\0\x12?\n\x10stripeStatistics\x18\x04\x20\x03(\x0b\
    2\x11.orc.proto.StreamR\x10stripeStatisticsB\0\x12(\n\x0efileStatistics\
    \x18\x05\x20\x01(\x0cR\x0efileStatisticsB\0:\0\"\xe3\x01\n\nEncryption\
    \x12)\n\x04mask\x18\x01\x20\x03(\x0b2\x13.orc.proto.DataMaskR\x04maskB\0\
    \x12,\n\x03key\x18\x02\x20\x03(\x0b2\x18.orc.proto.EncryptionKeyR\x03key\
    B\0\x12:\n\x08variants\x18\x03\x20\x03(\x0b2\x1c.orc.proto.EncryptionVar\
    iantR\x08variantsB\0\x12>\n\x0bkeyProvider\x18\x04\x20\x01(\x0e2\x1a.orc\
    .proto.KeyProviderKindR\x0bkeyProviderB\0:\0\"\xbb\x04\n\x06Footer\x12$\
    \n\x0cheaderLength\x18\x01\x20\x01(\x04R\x0cheaderLengthB\0\x12&\n\rcont\
    entLength\x18\x02\x20\x01(\x04R\rcontentLengthB\0\x128\n\x07stripes\x18\
    \x03\x20\x03(\x0b2\x1c.orc.proto.StripeInformationR\x07stripesB\0\x12'\n\
    \x05types\x18\x04\x20\x03(\x0b2\x0f.orc.proto.TypeR\x05typesB\0\x129\n\
    \x08metadata\x18\x05\x20\x03(\x0b2\x1b.orc.proto.UserMetadataItemR\x08me\
    tadataB\0\x12$\n\x0cnumberOfRows\x18\x06\x20\x01(\x04R\x0cnumberOfRowsB\
    \0\x12=\n\nstatistics\x18\x07\x20\x03(\x0b2\x1b.orc.proto.ColumnStatisti\
    csR\nstatisticsB\0\x12(\n\x0erowIndexStride\x18\x08\x20\x01(\rR\x0erowIn\
    dexStrideB\0\x12\x18\n\x06writer\x18\t\x20\x01(\rR\x06writerB\0\x127\n\n\
    encryption\x18\n\x20\x01(\x0b2\x15.orc.proto.EncryptionR\nencryptionB\0\
    \x125\n\x08calendar\x18\x0b\x20\x01(\x0e2\x17.orc.proto.CalendarKindR\
    \x08calendarB\0\x12*\n\x0fsoftwareVersion\x18\x0c\x20\x01(\tR\x0fsoftwar\
    eVersionB\0:\0\"\xed\x02\n\nPostScript\x12$\n\x0cfooterLength\x18\x01\
    \x20\x01(\x04R\x0cfooterLengthB\0\x12>\n\x0bcompression\x18\x02\x20\x01(\
    \x0e2\x1a.orc.proto.CompressionKindR\x0bcompressionB\0\x124\n\x14compres\
    sionBlockSize\x18\x03\x20\x01(\x04R\x14compressionBlockSizeB\0\x12\x1c\n\
    \x07version\x18\x04\x20\x03(\rR\x07versionB\x02\x10\x01\x12(\n\x0emetada\
    taLength\x18\x05\x20\x01(\x04R\x0emetadataLengthB\0\x12&\n\rwriterVersio\
    n\x18\x06\x20\x01(\rR\rwriterVersionB\0\x128\n\x16stripeStatisticsLength\
    \x18\x07\x20\x01(\x04R\x16stripeStatisticsLengthB\0\x12\x17\n\x05magic\
    \x18\xc0>\x20\x01(\tR\x05magicB\0:\0\"\xc2\x01\n\x08FileTail\x127\n\npos\
    tscript\x18\x01\x20\x01(\x0b2\x15.orc.proto.PostScriptR\npostscriptB\0\
    \x12+\n\x06footer\x18\x02\x20\x01(\x0b2\x11.orc.proto.FooterR\x06footerB\
    \0\x12\x20\n\nfileLength\x18\x03\x20\x01(\x04R\nfileLengthB\0\x12,\n\x10\
    postscriptLength\x18\x04\x20\x01(\x04R\x10postscriptLengthB\0:\0*Q\n\x13\
    EncryptionAlgorithm\x12\x16\n\x12UNKNOWN_ENCRYPTION\x10\0\x12\x0f\n\x0bA\
    ES_CTR_128\x10\x01\x12\x0f\n\x0bAES_CTR_256\x10\x02\x1a\0*I\n\x0fKeyProv\
    iderKind\x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\x06HADOOP\x10\x01\x12\x07\n\
    \x03AWS\x10\x02\x12\x07\n\x03GCP\x10\x03\x12\t\n\x05AZURE\x10\x04\x1a\0*\
    U\n\x0cCalendarKind\x12\x14\n\x10UNKNOWN_CALENDAR\x10\0\x12\x14\n\x10JUL\
    IAN_GREGORIAN\x10\x01\x12\x17\n\x13PROLEPTIC_GREGORIAN\x10\x02\x1a\0*O\n\
    \x0fCompressionKind\x12\x08\n\x04NONE\x10\0\x12\x08\n\x04ZLIB\x10\x01\
    \x12\n\n\x06SNAPPY\x10\x02\x12\x07\n\x03LZO\x10\x03\x12\x07\n\x03LZ4\x10\
    \x04\x12\x08\n\x04ZSTD\x10\x05\x1a\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
