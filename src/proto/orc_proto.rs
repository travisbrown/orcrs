// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `orc_proto.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.IntegerStatistics)
pub struct IntegerStatistics {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.IntegerStatistics.minimum)
    pub minimum: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:orc.proto.IntegerStatistics.maximum)
    pub maximum: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:orc.proto.IntegerStatistics.sum)
    pub sum: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.IntegerStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IntegerStatistics {
    fn default() -> &'a IntegerStatistics {
        <IntegerStatistics as ::protobuf::Message>::default_instance()
    }
}

impl IntegerStatistics {
    pub fn new() -> IntegerStatistics {
        ::std::default::Default::default()
    }

    // optional sint64 minimum = 1;

    pub fn minimum(&self) -> i64 {
        self.minimum.unwrap_or(0)
    }

    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: i64) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // optional sint64 maximum = 2;

    pub fn maximum(&self) -> i64 {
        self.maximum.unwrap_or(0)
    }

    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: i64) {
        self.maximum = ::std::option::Option::Some(v);
    }

    // optional sint64 sum = 3;

    pub fn sum(&self) -> i64 {
        self.sum.unwrap_or(0)
    }

    pub fn clear_sum(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: i64) {
        self.sum = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minimum",
            |m: &IntegerStatistics| { &m.minimum },
            |m: &mut IntegerStatistics| { &mut m.minimum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximum",
            |m: &IntegerStatistics| { &m.maximum },
            |m: &mut IntegerStatistics| { &mut m.maximum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sum",
            |m: &IntegerStatistics| { &m.sum },
            |m: &mut IntegerStatistics| { &mut m.sum },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IntegerStatistics>(
            "IntegerStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IntegerStatistics {
    const NAME: &'static str = "IntegerStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.minimum = ::std::option::Option::Some(is.read_sint64()?);
                },
                16 => {
                    self.maximum = ::std::option::Option::Some(is.read_sint64()?);
                },
                24 => {
                    self.sum = ::std::option::Option::Some(is.read_sint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.minimum {
            my_size += ::protobuf::rt::sint64_size(1, v);
        }
        if let Some(v) = self.maximum {
            my_size += ::protobuf::rt::sint64_size(2, v);
        }
        if let Some(v) = self.sum {
            my_size += ::protobuf::rt::sint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.minimum {
            os.write_sint64(1, v)?;
        }
        if let Some(v) = self.maximum {
            os.write_sint64(2, v)?;
        }
        if let Some(v) = self.sum {
            os.write_sint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IntegerStatistics {
        IntegerStatistics::new()
    }

    fn clear(&mut self) {
        self.minimum = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IntegerStatistics {
        static instance: IntegerStatistics = IntegerStatistics {
            minimum: ::std::option::Option::None,
            maximum: ::std::option::Option::None,
            sum: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IntegerStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IntegerStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IntegerStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntegerStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.DoubleStatistics)
pub struct DoubleStatistics {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.DoubleStatistics.minimum)
    pub minimum: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:orc.proto.DoubleStatistics.maximum)
    pub maximum: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:orc.proto.DoubleStatistics.sum)
    pub sum: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.DoubleStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DoubleStatistics {
    fn default() -> &'a DoubleStatistics {
        <DoubleStatistics as ::protobuf::Message>::default_instance()
    }
}

impl DoubleStatistics {
    pub fn new() -> DoubleStatistics {
        ::std::default::Default::default()
    }

    // optional double minimum = 1;

    pub fn minimum(&self) -> f64 {
        self.minimum.unwrap_or(0.)
    }

    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: f64) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // optional double maximum = 2;

    pub fn maximum(&self) -> f64 {
        self.maximum.unwrap_or(0.)
    }

    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: f64) {
        self.maximum = ::std::option::Option::Some(v);
    }

    // optional double sum = 3;

    pub fn sum(&self) -> f64 {
        self.sum.unwrap_or(0.)
    }

    pub fn clear_sum(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: f64) {
        self.sum = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minimum",
            |m: &DoubleStatistics| { &m.minimum },
            |m: &mut DoubleStatistics| { &mut m.minimum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximum",
            |m: &DoubleStatistics| { &m.maximum },
            |m: &mut DoubleStatistics| { &mut m.maximum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sum",
            |m: &DoubleStatistics| { &m.sum },
            |m: &mut DoubleStatistics| { &mut m.sum },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DoubleStatistics>(
            "DoubleStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DoubleStatistics {
    const NAME: &'static str = "DoubleStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.minimum = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.maximum = ::std::option::Option::Some(is.read_double()?);
                },
                25 => {
                    self.sum = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.minimum {
            my_size += 1 + 8;
        }
        if let Some(v) = self.maximum {
            my_size += 1 + 8;
        }
        if let Some(v) = self.sum {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.minimum {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.maximum {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.sum {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DoubleStatistics {
        DoubleStatistics::new()
    }

    fn clear(&mut self) {
        self.minimum = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DoubleStatistics {
        static instance: DoubleStatistics = DoubleStatistics {
            minimum: ::std::option::Option::None,
            maximum: ::std::option::Option::None,
            sum: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DoubleStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DoubleStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DoubleStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoubleStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.StringStatistics)
pub struct StringStatistics {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.StringStatistics.minimum)
    pub minimum: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:orc.proto.StringStatistics.maximum)
    pub maximum: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:orc.proto.StringStatistics.sum)
    pub sum: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:orc.proto.StringStatistics.lowerBound)
    pub lowerBound: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:orc.proto.StringStatistics.upperBound)
    pub upperBound: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.StringStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StringStatistics {
    fn default() -> &'a StringStatistics {
        <StringStatistics as ::protobuf::Message>::default_instance()
    }
}

impl StringStatistics {
    pub fn new() -> StringStatistics {
        ::std::default::Default::default()
    }

    // optional string minimum = 1;

    pub fn minimum(&self) -> &str {
        match self.minimum.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: ::std::string::String) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minimum(&mut self) -> &mut ::std::string::String {
        if self.minimum.is_none() {
            self.minimum = ::std::option::Option::Some(::std::string::String::new());
        }
        self.minimum.as_mut().unwrap()
    }

    // Take field
    pub fn take_minimum(&mut self) -> ::std::string::String {
        self.minimum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string maximum = 2;

    pub fn maximum(&self) -> &str {
        match self.maximum.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: ::std::string::String) {
        self.maximum = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maximum(&mut self) -> &mut ::std::string::String {
        if self.maximum.is_none() {
            self.maximum = ::std::option::Option::Some(::std::string::String::new());
        }
        self.maximum.as_mut().unwrap()
    }

    // Take field
    pub fn take_maximum(&mut self) -> ::std::string::String {
        self.maximum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint64 sum = 3;

    pub fn sum(&self) -> i64 {
        self.sum.unwrap_or(0)
    }

    pub fn clear_sum(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: i64) {
        self.sum = ::std::option::Option::Some(v);
    }

    // optional string lowerBound = 4;

    pub fn lowerBound(&self) -> &str {
        match self.lowerBound.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lowerBound(&mut self) {
        self.lowerBound = ::std::option::Option::None;
    }

    pub fn has_lowerBound(&self) -> bool {
        self.lowerBound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lowerBound(&mut self, v: ::std::string::String) {
        self.lowerBound = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lowerBound(&mut self) -> &mut ::std::string::String {
        if self.lowerBound.is_none() {
            self.lowerBound = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lowerBound.as_mut().unwrap()
    }

    // Take field
    pub fn take_lowerBound(&mut self) -> ::std::string::String {
        self.lowerBound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string upperBound = 5;

    pub fn upperBound(&self) -> &str {
        match self.upperBound.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_upperBound(&mut self) {
        self.upperBound = ::std::option::Option::None;
    }

    pub fn has_upperBound(&self) -> bool {
        self.upperBound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upperBound(&mut self, v: ::std::string::String) {
        self.upperBound = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upperBound(&mut self) -> &mut ::std::string::String {
        if self.upperBound.is_none() {
            self.upperBound = ::std::option::Option::Some(::std::string::String::new());
        }
        self.upperBound.as_mut().unwrap()
    }

    // Take field
    pub fn take_upperBound(&mut self) -> ::std::string::String {
        self.upperBound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minimum",
            |m: &StringStatistics| { &m.minimum },
            |m: &mut StringStatistics| { &mut m.minimum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximum",
            |m: &StringStatistics| { &m.maximum },
            |m: &mut StringStatistics| { &mut m.maximum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sum",
            |m: &StringStatistics| { &m.sum },
            |m: &mut StringStatistics| { &mut m.sum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lowerBound",
            |m: &StringStatistics| { &m.lowerBound },
            |m: &mut StringStatistics| { &mut m.lowerBound },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upperBound",
            |m: &StringStatistics| { &m.upperBound },
            |m: &mut StringStatistics| { &mut m.upperBound },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StringStatistics>(
            "StringStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StringStatistics {
    const NAME: &'static str = "StringStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.minimum = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.maximum = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.sum = ::std::option::Option::Some(is.read_sint64()?);
                },
                34 => {
                    self.lowerBound = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.upperBound = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.minimum.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.maximum.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.sum {
            my_size += ::protobuf::rt::sint64_size(3, v);
        }
        if let Some(v) = self.lowerBound.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.upperBound.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.minimum.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.maximum.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.sum {
            os.write_sint64(3, v)?;
        }
        if let Some(v) = self.lowerBound.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.upperBound.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StringStatistics {
        StringStatistics::new()
    }

    fn clear(&mut self) {
        self.minimum = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.lowerBound = ::std::option::Option::None;
        self.upperBound = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StringStatistics {
        static instance: StringStatistics = StringStatistics {
            minimum: ::std::option::Option::None,
            maximum: ::std::option::Option::None,
            sum: ::std::option::Option::None,
            lowerBound: ::std::option::Option::None,
            upperBound: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StringStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StringStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StringStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.BucketStatistics)
pub struct BucketStatistics {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.BucketStatistics.count)
    pub count: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.BucketStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BucketStatistics {
    fn default() -> &'a BucketStatistics {
        <BucketStatistics as ::protobuf::Message>::default_instance()
    }
}

impl BucketStatistics {
    pub fn new() -> BucketStatistics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "count",
            |m: &BucketStatistics| { &m.count },
            |m: &mut BucketStatistics| { &mut m.count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BucketStatistics>(
            "BucketStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BucketStatistics {
    const NAME: &'static str = "BucketStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.count)?;
                },
                8 => {
                    self.count.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_uint64_size(1, &self.count);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_uint64(1, &self.count)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BucketStatistics {
        BucketStatistics::new()
    }

    fn clear(&mut self) {
        self.count.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BucketStatistics {
        static instance: BucketStatistics = BucketStatistics {
            count: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BucketStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BucketStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BucketStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BucketStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.DecimalStatistics)
pub struct DecimalStatistics {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.DecimalStatistics.minimum)
    pub minimum: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:orc.proto.DecimalStatistics.maximum)
    pub maximum: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:orc.proto.DecimalStatistics.sum)
    pub sum: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.DecimalStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DecimalStatistics {
    fn default() -> &'a DecimalStatistics {
        <DecimalStatistics as ::protobuf::Message>::default_instance()
    }
}

impl DecimalStatistics {
    pub fn new() -> DecimalStatistics {
        ::std::default::Default::default()
    }

    // optional string minimum = 1;

    pub fn minimum(&self) -> &str {
        match self.minimum.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: ::std::string::String) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minimum(&mut self) -> &mut ::std::string::String {
        if self.minimum.is_none() {
            self.minimum = ::std::option::Option::Some(::std::string::String::new());
        }
        self.minimum.as_mut().unwrap()
    }

    // Take field
    pub fn take_minimum(&mut self) -> ::std::string::String {
        self.minimum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string maximum = 2;

    pub fn maximum(&self) -> &str {
        match self.maximum.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: ::std::string::String) {
        self.maximum = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maximum(&mut self) -> &mut ::std::string::String {
        if self.maximum.is_none() {
            self.maximum = ::std::option::Option::Some(::std::string::String::new());
        }
        self.maximum.as_mut().unwrap()
    }

    // Take field
    pub fn take_maximum(&mut self) -> ::std::string::String {
        self.maximum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sum = 3;

    pub fn sum(&self) -> &str {
        match self.sum.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sum(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: ::std::string::String) {
        self.sum = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sum(&mut self) -> &mut ::std::string::String {
        if self.sum.is_none() {
            self.sum = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sum.as_mut().unwrap()
    }

    // Take field
    pub fn take_sum(&mut self) -> ::std::string::String {
        self.sum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minimum",
            |m: &DecimalStatistics| { &m.minimum },
            |m: &mut DecimalStatistics| { &mut m.minimum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximum",
            |m: &DecimalStatistics| { &m.maximum },
            |m: &mut DecimalStatistics| { &mut m.maximum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sum",
            |m: &DecimalStatistics| { &m.sum },
            |m: &mut DecimalStatistics| { &mut m.sum },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DecimalStatistics>(
            "DecimalStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DecimalStatistics {
    const NAME: &'static str = "DecimalStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.minimum = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.maximum = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.sum = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.minimum.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.maximum.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.sum.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.minimum.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.maximum.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.sum.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DecimalStatistics {
        DecimalStatistics::new()
    }

    fn clear(&mut self) {
        self.minimum = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DecimalStatistics {
        static instance: DecimalStatistics = DecimalStatistics {
            minimum: ::std::option::Option::None,
            maximum: ::std::option::Option::None,
            sum: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DecimalStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DecimalStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DecimalStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecimalStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.DateStatistics)
pub struct DateStatistics {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.DateStatistics.minimum)
    pub minimum: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:orc.proto.DateStatistics.maximum)
    pub maximum: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.DateStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DateStatistics {
    fn default() -> &'a DateStatistics {
        <DateStatistics as ::protobuf::Message>::default_instance()
    }
}

impl DateStatistics {
    pub fn new() -> DateStatistics {
        ::std::default::Default::default()
    }

    // optional sint32 minimum = 1;

    pub fn minimum(&self) -> i32 {
        self.minimum.unwrap_or(0)
    }

    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: i32) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // optional sint32 maximum = 2;

    pub fn maximum(&self) -> i32 {
        self.maximum.unwrap_or(0)
    }

    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: i32) {
        self.maximum = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minimum",
            |m: &DateStatistics| { &m.minimum },
            |m: &mut DateStatistics| { &mut m.minimum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximum",
            |m: &DateStatistics| { &m.maximum },
            |m: &mut DateStatistics| { &mut m.maximum },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DateStatistics>(
            "DateStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DateStatistics {
    const NAME: &'static str = "DateStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.minimum = ::std::option::Option::Some(is.read_sint32()?);
                },
                16 => {
                    self.maximum = ::std::option::Option::Some(is.read_sint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.minimum {
            my_size += ::protobuf::rt::sint32_size(1, v);
        }
        if let Some(v) = self.maximum {
            my_size += ::protobuf::rt::sint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.minimum {
            os.write_sint32(1, v)?;
        }
        if let Some(v) = self.maximum {
            os.write_sint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DateStatistics {
        DateStatistics::new()
    }

    fn clear(&mut self) {
        self.minimum = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DateStatistics {
        static instance: DateStatistics = DateStatistics {
            minimum: ::std::option::Option::None,
            maximum: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DateStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DateStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DateStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DateStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.TimestampStatistics)
pub struct TimestampStatistics {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.TimestampStatistics.minimum)
    pub minimum: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:orc.proto.TimestampStatistics.maximum)
    pub maximum: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:orc.proto.TimestampStatistics.minimumUtc)
    pub minimumUtc: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:orc.proto.TimestampStatistics.maximumUtc)
    pub maximumUtc: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:orc.proto.TimestampStatistics.minimumNanos)
    pub minimumNanos: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:orc.proto.TimestampStatistics.maximumNanos)
    pub maximumNanos: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.TimestampStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimestampStatistics {
    fn default() -> &'a TimestampStatistics {
        <TimestampStatistics as ::protobuf::Message>::default_instance()
    }
}

impl TimestampStatistics {
    pub fn new() -> TimestampStatistics {
        ::std::default::Default::default()
    }

    // optional sint64 minimum = 1;

    pub fn minimum(&self) -> i64 {
        self.minimum.unwrap_or(0)
    }

    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: i64) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // optional sint64 maximum = 2;

    pub fn maximum(&self) -> i64 {
        self.maximum.unwrap_or(0)
    }

    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: i64) {
        self.maximum = ::std::option::Option::Some(v);
    }

    // optional sint64 minimumUtc = 3;

    pub fn minimumUtc(&self) -> i64 {
        self.minimumUtc.unwrap_or(0)
    }

    pub fn clear_minimumUtc(&mut self) {
        self.minimumUtc = ::std::option::Option::None;
    }

    pub fn has_minimumUtc(&self) -> bool {
        self.minimumUtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimumUtc(&mut self, v: i64) {
        self.minimumUtc = ::std::option::Option::Some(v);
    }

    // optional sint64 maximumUtc = 4;

    pub fn maximumUtc(&self) -> i64 {
        self.maximumUtc.unwrap_or(0)
    }

    pub fn clear_maximumUtc(&mut self) {
        self.maximumUtc = ::std::option::Option::None;
    }

    pub fn has_maximumUtc(&self) -> bool {
        self.maximumUtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximumUtc(&mut self, v: i64) {
        self.maximumUtc = ::std::option::Option::Some(v);
    }

    // optional int32 minimumNanos = 5;

    pub fn minimumNanos(&self) -> i32 {
        self.minimumNanos.unwrap_or(0)
    }

    pub fn clear_minimumNanos(&mut self) {
        self.minimumNanos = ::std::option::Option::None;
    }

    pub fn has_minimumNanos(&self) -> bool {
        self.minimumNanos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimumNanos(&mut self, v: i32) {
        self.minimumNanos = ::std::option::Option::Some(v);
    }

    // optional int32 maximumNanos = 6;

    pub fn maximumNanos(&self) -> i32 {
        self.maximumNanos.unwrap_or(0)
    }

    pub fn clear_maximumNanos(&mut self) {
        self.maximumNanos = ::std::option::Option::None;
    }

    pub fn has_maximumNanos(&self) -> bool {
        self.maximumNanos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximumNanos(&mut self, v: i32) {
        self.maximumNanos = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minimum",
            |m: &TimestampStatistics| { &m.minimum },
            |m: &mut TimestampStatistics| { &mut m.minimum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximum",
            |m: &TimestampStatistics| { &m.maximum },
            |m: &mut TimestampStatistics| { &mut m.maximum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minimumUtc",
            |m: &TimestampStatistics| { &m.minimumUtc },
            |m: &mut TimestampStatistics| { &mut m.minimumUtc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximumUtc",
            |m: &TimestampStatistics| { &m.maximumUtc },
            |m: &mut TimestampStatistics| { &mut m.maximumUtc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minimumNanos",
            |m: &TimestampStatistics| { &m.minimumNanos },
            |m: &mut TimestampStatistics| { &mut m.minimumNanos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximumNanos",
            |m: &TimestampStatistics| { &m.maximumNanos },
            |m: &mut TimestampStatistics| { &mut m.maximumNanos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimestampStatistics>(
            "TimestampStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimestampStatistics {
    const NAME: &'static str = "TimestampStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.minimum = ::std::option::Option::Some(is.read_sint64()?);
                },
                16 => {
                    self.maximum = ::std::option::Option::Some(is.read_sint64()?);
                },
                24 => {
                    self.minimumUtc = ::std::option::Option::Some(is.read_sint64()?);
                },
                32 => {
                    self.maximumUtc = ::std::option::Option::Some(is.read_sint64()?);
                },
                40 => {
                    self.minimumNanos = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.maximumNanos = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.minimum {
            my_size += ::protobuf::rt::sint64_size(1, v);
        }
        if let Some(v) = self.maximum {
            my_size += ::protobuf::rt::sint64_size(2, v);
        }
        if let Some(v) = self.minimumUtc {
            my_size += ::protobuf::rt::sint64_size(3, v);
        }
        if let Some(v) = self.maximumUtc {
            my_size += ::protobuf::rt::sint64_size(4, v);
        }
        if let Some(v) = self.minimumNanos {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.maximumNanos {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.minimum {
            os.write_sint64(1, v)?;
        }
        if let Some(v) = self.maximum {
            os.write_sint64(2, v)?;
        }
        if let Some(v) = self.minimumUtc {
            os.write_sint64(3, v)?;
        }
        if let Some(v) = self.maximumUtc {
            os.write_sint64(4, v)?;
        }
        if let Some(v) = self.minimumNanos {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.maximumNanos {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimestampStatistics {
        TimestampStatistics::new()
    }

    fn clear(&mut self) {
        self.minimum = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.minimumUtc = ::std::option::Option::None;
        self.maximumUtc = ::std::option::Option::None;
        self.minimumNanos = ::std::option::Option::None;
        self.maximumNanos = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimestampStatistics {
        static instance: TimestampStatistics = TimestampStatistics {
            minimum: ::std::option::Option::None,
            maximum: ::std::option::Option::None,
            minimumUtc: ::std::option::Option::None,
            maximumUtc: ::std::option::Option::None,
            minimumNanos: ::std::option::Option::None,
            maximumNanos: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimestampStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimestampStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimestampStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimestampStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.BinaryStatistics)
pub struct BinaryStatistics {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.BinaryStatistics.sum)
    pub sum: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.BinaryStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BinaryStatistics {
    fn default() -> &'a BinaryStatistics {
        <BinaryStatistics as ::protobuf::Message>::default_instance()
    }
}

impl BinaryStatistics {
    pub fn new() -> BinaryStatistics {
        ::std::default::Default::default()
    }

    // optional sint64 sum = 1;

    pub fn sum(&self) -> i64 {
        self.sum.unwrap_or(0)
    }

    pub fn clear_sum(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sum(&self) -> bool {
        self.sum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: i64) {
        self.sum = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sum",
            |m: &BinaryStatistics| { &m.sum },
            |m: &mut BinaryStatistics| { &mut m.sum },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BinaryStatistics>(
            "BinaryStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BinaryStatistics {
    const NAME: &'static str = "BinaryStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sum = ::std::option::Option::Some(is.read_sint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sum {
            my_size += ::protobuf::rt::sint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sum {
            os.write_sint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BinaryStatistics {
        BinaryStatistics::new()
    }

    fn clear(&mut self) {
        self.sum = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BinaryStatistics {
        static instance: BinaryStatistics = BinaryStatistics {
            sum: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BinaryStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BinaryStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BinaryStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.CollectionStatistics)
pub struct CollectionStatistics {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.CollectionStatistics.minChildren)
    pub minChildren: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.CollectionStatistics.maxChildren)
    pub maxChildren: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.CollectionStatistics.totalChildren)
    pub totalChildren: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.CollectionStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CollectionStatistics {
    fn default() -> &'a CollectionStatistics {
        <CollectionStatistics as ::protobuf::Message>::default_instance()
    }
}

impl CollectionStatistics {
    pub fn new() -> CollectionStatistics {
        ::std::default::Default::default()
    }

    // optional uint64 minChildren = 1;

    pub fn minChildren(&self) -> u64 {
        self.minChildren.unwrap_or(0)
    }

    pub fn clear_minChildren(&mut self) {
        self.minChildren = ::std::option::Option::None;
    }

    pub fn has_minChildren(&self) -> bool {
        self.minChildren.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minChildren(&mut self, v: u64) {
        self.minChildren = ::std::option::Option::Some(v);
    }

    // optional uint64 maxChildren = 2;

    pub fn maxChildren(&self) -> u64 {
        self.maxChildren.unwrap_or(0)
    }

    pub fn clear_maxChildren(&mut self) {
        self.maxChildren = ::std::option::Option::None;
    }

    pub fn has_maxChildren(&self) -> bool {
        self.maxChildren.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxChildren(&mut self, v: u64) {
        self.maxChildren = ::std::option::Option::Some(v);
    }

    // optional uint64 totalChildren = 3;

    pub fn totalChildren(&self) -> u64 {
        self.totalChildren.unwrap_or(0)
    }

    pub fn clear_totalChildren(&mut self) {
        self.totalChildren = ::std::option::Option::None;
    }

    pub fn has_totalChildren(&self) -> bool {
        self.totalChildren.is_some()
    }

    // Param is passed by value, moved
    pub fn set_totalChildren(&mut self, v: u64) {
        self.totalChildren = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minChildren",
            |m: &CollectionStatistics| { &m.minChildren },
            |m: &mut CollectionStatistics| { &mut m.minChildren },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maxChildren",
            |m: &CollectionStatistics| { &m.maxChildren },
            |m: &mut CollectionStatistics| { &mut m.maxChildren },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "totalChildren",
            |m: &CollectionStatistics| { &m.totalChildren },
            |m: &mut CollectionStatistics| { &mut m.totalChildren },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CollectionStatistics>(
            "CollectionStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CollectionStatistics {
    const NAME: &'static str = "CollectionStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.minChildren = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.maxChildren = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.totalChildren = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.minChildren {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.maxChildren {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.totalChildren {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.minChildren {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.maxChildren {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.totalChildren {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CollectionStatistics {
        CollectionStatistics::new()
    }

    fn clear(&mut self) {
        self.minChildren = ::std::option::Option::None;
        self.maxChildren = ::std::option::Option::None;
        self.totalChildren = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CollectionStatistics {
        static instance: CollectionStatistics = CollectionStatistics {
            minChildren: ::std::option::Option::None,
            maxChildren: ::std::option::Option::None,
            totalChildren: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CollectionStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CollectionStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CollectionStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectionStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.ColumnStatistics)
pub struct ColumnStatistics {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.ColumnStatistics.numberOfValues)
    pub numberOfValues: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.ColumnStatistics.intStatistics)
    pub intStatistics: ::protobuf::MessageField<IntegerStatistics>,
    // @@protoc_insertion_point(field:orc.proto.ColumnStatistics.doubleStatistics)
    pub doubleStatistics: ::protobuf::MessageField<DoubleStatistics>,
    // @@protoc_insertion_point(field:orc.proto.ColumnStatistics.stringStatistics)
    pub stringStatistics: ::protobuf::MessageField<StringStatistics>,
    // @@protoc_insertion_point(field:orc.proto.ColumnStatistics.bucketStatistics)
    pub bucketStatistics: ::protobuf::MessageField<BucketStatistics>,
    // @@protoc_insertion_point(field:orc.proto.ColumnStatistics.decimalStatistics)
    pub decimalStatistics: ::protobuf::MessageField<DecimalStatistics>,
    // @@protoc_insertion_point(field:orc.proto.ColumnStatistics.dateStatistics)
    pub dateStatistics: ::protobuf::MessageField<DateStatistics>,
    // @@protoc_insertion_point(field:orc.proto.ColumnStatistics.binaryStatistics)
    pub binaryStatistics: ::protobuf::MessageField<BinaryStatistics>,
    // @@protoc_insertion_point(field:orc.proto.ColumnStatistics.timestampStatistics)
    pub timestampStatistics: ::protobuf::MessageField<TimestampStatistics>,
    // @@protoc_insertion_point(field:orc.proto.ColumnStatistics.hasNull)
    pub hasNull: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:orc.proto.ColumnStatistics.bytesOnDisk)
    pub bytesOnDisk: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.ColumnStatistics.collectionStatistics)
    pub collectionStatistics: ::protobuf::MessageField<CollectionStatistics>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.ColumnStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ColumnStatistics {
    fn default() -> &'a ColumnStatistics {
        <ColumnStatistics as ::protobuf::Message>::default_instance()
    }
}

impl ColumnStatistics {
    pub fn new() -> ColumnStatistics {
        ::std::default::Default::default()
    }

    // optional uint64 numberOfValues = 1;

    pub fn numberOfValues(&self) -> u64 {
        self.numberOfValues.unwrap_or(0)
    }

    pub fn clear_numberOfValues(&mut self) {
        self.numberOfValues = ::std::option::Option::None;
    }

    pub fn has_numberOfValues(&self) -> bool {
        self.numberOfValues.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberOfValues(&mut self, v: u64) {
        self.numberOfValues = ::std::option::Option::Some(v);
    }

    // optional bool hasNull = 10;

    pub fn hasNull(&self) -> bool {
        self.hasNull.unwrap_or(false)
    }

    pub fn clear_hasNull(&mut self) {
        self.hasNull = ::std::option::Option::None;
    }

    pub fn has_hasNull(&self) -> bool {
        self.hasNull.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasNull(&mut self, v: bool) {
        self.hasNull = ::std::option::Option::Some(v);
    }

    // optional uint64 bytesOnDisk = 11;

    pub fn bytesOnDisk(&self) -> u64 {
        self.bytesOnDisk.unwrap_or(0)
    }

    pub fn clear_bytesOnDisk(&mut self) {
        self.bytesOnDisk = ::std::option::Option::None;
    }

    pub fn has_bytesOnDisk(&self) -> bool {
        self.bytesOnDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesOnDisk(&mut self, v: u64) {
        self.bytesOnDisk = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberOfValues",
            |m: &ColumnStatistics| { &m.numberOfValues },
            |m: &mut ColumnStatistics| { &mut m.numberOfValues },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IntegerStatistics>(
            "intStatistics",
            |m: &ColumnStatistics| { &m.intStatistics },
            |m: &mut ColumnStatistics| { &mut m.intStatistics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DoubleStatistics>(
            "doubleStatistics",
            |m: &ColumnStatistics| { &m.doubleStatistics },
            |m: &mut ColumnStatistics| { &mut m.doubleStatistics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StringStatistics>(
            "stringStatistics",
            |m: &ColumnStatistics| { &m.stringStatistics },
            |m: &mut ColumnStatistics| { &mut m.stringStatistics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BucketStatistics>(
            "bucketStatistics",
            |m: &ColumnStatistics| { &m.bucketStatistics },
            |m: &mut ColumnStatistics| { &mut m.bucketStatistics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DecimalStatistics>(
            "decimalStatistics",
            |m: &ColumnStatistics| { &m.decimalStatistics },
            |m: &mut ColumnStatistics| { &mut m.decimalStatistics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DateStatistics>(
            "dateStatistics",
            |m: &ColumnStatistics| { &m.dateStatistics },
            |m: &mut ColumnStatistics| { &mut m.dateStatistics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BinaryStatistics>(
            "binaryStatistics",
            |m: &ColumnStatistics| { &m.binaryStatistics },
            |m: &mut ColumnStatistics| { &mut m.binaryStatistics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TimestampStatistics>(
            "timestampStatistics",
            |m: &ColumnStatistics| { &m.timestampStatistics },
            |m: &mut ColumnStatistics| { &mut m.timestampStatistics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hasNull",
            |m: &ColumnStatistics| { &m.hasNull },
            |m: &mut ColumnStatistics| { &mut m.hasNull },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytesOnDisk",
            |m: &ColumnStatistics| { &m.bytesOnDisk },
            |m: &mut ColumnStatistics| { &mut m.bytesOnDisk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CollectionStatistics>(
            "collectionStatistics",
            |m: &ColumnStatistics| { &m.collectionStatistics },
            |m: &mut ColumnStatistics| { &mut m.collectionStatistics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColumnStatistics>(
            "ColumnStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ColumnStatistics {
    const NAME: &'static str = "ColumnStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.numberOfValues = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.intStatistics)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.doubleStatistics)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stringStatistics)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bucketStatistics)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.decimalStatistics)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dateStatistics)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.binaryStatistics)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestampStatistics)?;
                },
                80 => {
                    self.hasNull = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.bytesOnDisk = ::std::option::Option::Some(is.read_uint64()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.collectionStatistics)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.numberOfValues {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.intStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.doubleStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stringStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bucketStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.decimalStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dateStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.binaryStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timestampStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hasNull {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bytesOnDisk {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        if let Some(v) = self.collectionStatistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.numberOfValues {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.intStatistics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.doubleStatistics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.stringStatistics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.bucketStatistics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.decimalStatistics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.dateStatistics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.binaryStatistics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.timestampStatistics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.hasNull {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.bytesOnDisk {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.collectionStatistics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ColumnStatistics {
        ColumnStatistics::new()
    }

    fn clear(&mut self) {
        self.numberOfValues = ::std::option::Option::None;
        self.intStatistics.clear();
        self.doubleStatistics.clear();
        self.stringStatistics.clear();
        self.bucketStatistics.clear();
        self.decimalStatistics.clear();
        self.dateStatistics.clear();
        self.binaryStatistics.clear();
        self.timestampStatistics.clear();
        self.hasNull = ::std::option::Option::None;
        self.bytesOnDisk = ::std::option::Option::None;
        self.collectionStatistics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ColumnStatistics {
        static instance: ColumnStatistics = ColumnStatistics {
            numberOfValues: ::std::option::Option::None,
            intStatistics: ::protobuf::MessageField::none(),
            doubleStatistics: ::protobuf::MessageField::none(),
            stringStatistics: ::protobuf::MessageField::none(),
            bucketStatistics: ::protobuf::MessageField::none(),
            decimalStatistics: ::protobuf::MessageField::none(),
            dateStatistics: ::protobuf::MessageField::none(),
            binaryStatistics: ::protobuf::MessageField::none(),
            timestampStatistics: ::protobuf::MessageField::none(),
            hasNull: ::std::option::Option::None,
            bytesOnDisk: ::std::option::Option::None,
            collectionStatistics: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ColumnStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ColumnStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ColumnStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.RowIndexEntry)
pub struct RowIndexEntry {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.RowIndexEntry.positions)
    pub positions: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:orc.proto.RowIndexEntry.statistics)
    pub statistics: ::protobuf::MessageField<ColumnStatistics>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.RowIndexEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RowIndexEntry {
    fn default() -> &'a RowIndexEntry {
        <RowIndexEntry as ::protobuf::Message>::default_instance()
    }
}

impl RowIndexEntry {
    pub fn new() -> RowIndexEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "positions",
            |m: &RowIndexEntry| { &m.positions },
            |m: &mut RowIndexEntry| { &mut m.positions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ColumnStatistics>(
            "statistics",
            |m: &RowIndexEntry| { &m.statistics },
            |m: &mut RowIndexEntry| { &mut m.statistics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RowIndexEntry>(
            "RowIndexEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RowIndexEntry {
    const NAME: &'static str = "RowIndexEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.positions)?;
                },
                8 => {
                    self.positions.push(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.statistics)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_uint64_size(1, &self.positions);
        if let Some(v) = self.statistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_uint64(1, &self.positions)?;
        if let Some(v) = self.statistics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RowIndexEntry {
        RowIndexEntry::new()
    }

    fn clear(&mut self) {
        self.positions.clear();
        self.statistics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RowIndexEntry {
        static instance: RowIndexEntry = RowIndexEntry {
            positions: ::std::vec::Vec::new(),
            statistics: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RowIndexEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RowIndexEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RowIndexEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowIndexEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.RowIndex)
pub struct RowIndex {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.RowIndex.entry)
    pub entry: ::std::vec::Vec<RowIndexEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.RowIndex.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RowIndex {
    fn default() -> &'a RowIndex {
        <RowIndex as ::protobuf::Message>::default_instance()
    }
}

impl RowIndex {
    pub fn new() -> RowIndex {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entry",
            |m: &RowIndex| { &m.entry },
            |m: &mut RowIndex| { &mut m.entry },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RowIndex>(
            "RowIndex",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RowIndex {
    const NAME: &'static str = "RowIndex";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entry.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entry {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RowIndex {
        RowIndex::new()
    }

    fn clear(&mut self) {
        self.entry.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RowIndex {
        static instance: RowIndex = RowIndex {
            entry: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RowIndex {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RowIndex").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RowIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowIndex {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.BloomFilter)
pub struct BloomFilter {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.BloomFilter.numHashFunctions)
    pub numHashFunctions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:orc.proto.BloomFilter.bitset)
    pub bitset: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:orc.proto.BloomFilter.utf8bitset)
    pub utf8bitset: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.BloomFilter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BloomFilter {
    fn default() -> &'a BloomFilter {
        <BloomFilter as ::protobuf::Message>::default_instance()
    }
}

impl BloomFilter {
    pub fn new() -> BloomFilter {
        ::std::default::Default::default()
    }

    // optional uint32 numHashFunctions = 1;

    pub fn numHashFunctions(&self) -> u32 {
        self.numHashFunctions.unwrap_or(0)
    }

    pub fn clear_numHashFunctions(&mut self) {
        self.numHashFunctions = ::std::option::Option::None;
    }

    pub fn has_numHashFunctions(&self) -> bool {
        self.numHashFunctions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numHashFunctions(&mut self, v: u32) {
        self.numHashFunctions = ::std::option::Option::Some(v);
    }

    // optional bytes utf8bitset = 3;

    pub fn utf8bitset(&self) -> &[u8] {
        match self.utf8bitset.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_utf8bitset(&mut self) {
        self.utf8bitset = ::std::option::Option::None;
    }

    pub fn has_utf8bitset(&self) -> bool {
        self.utf8bitset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utf8bitset(&mut self, v: ::std::vec::Vec<u8>) {
        self.utf8bitset = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_utf8bitset(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.utf8bitset.is_none() {
            self.utf8bitset = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.utf8bitset.as_mut().unwrap()
    }

    // Take field
    pub fn take_utf8bitset(&mut self) -> ::std::vec::Vec<u8> {
        self.utf8bitset.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numHashFunctions",
            |m: &BloomFilter| { &m.numHashFunctions },
            |m: &mut BloomFilter| { &mut m.numHashFunctions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bitset",
            |m: &BloomFilter| { &m.bitset },
            |m: &mut BloomFilter| { &mut m.bitset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "utf8bitset",
            |m: &BloomFilter| { &m.utf8bitset },
            |m: &mut BloomFilter| { &mut m.utf8bitset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BloomFilter>(
            "BloomFilter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BloomFilter {
    const NAME: &'static str = "BloomFilter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.numHashFunctions = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_fixed64_into(&mut self.bitset)?;
                },
                17 => {
                    self.bitset.push(is.read_fixed64()?);
                },
                26 => {
                    self.utf8bitset = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.numHashFunctions {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += 9 * self.bitset.len() as u64;
        if let Some(v) = self.utf8bitset.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.numHashFunctions {
            os.write_uint32(1, v)?;
        }
        for v in &self.bitset {
            os.write_fixed64(2, *v)?;
        };
        if let Some(v) = self.utf8bitset.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BloomFilter {
        BloomFilter::new()
    }

    fn clear(&mut self) {
        self.numHashFunctions = ::std::option::Option::None;
        self.bitset.clear();
        self.utf8bitset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BloomFilter {
        static instance: BloomFilter = BloomFilter {
            numHashFunctions: ::std::option::Option::None,
            bitset: ::std::vec::Vec::new(),
            utf8bitset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BloomFilter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BloomFilter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BloomFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BloomFilter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.BloomFilterIndex)
pub struct BloomFilterIndex {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.BloomFilterIndex.bloomFilter)
    pub bloomFilter: ::std::vec::Vec<BloomFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.BloomFilterIndex.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BloomFilterIndex {
    fn default() -> &'a BloomFilterIndex {
        <BloomFilterIndex as ::protobuf::Message>::default_instance()
    }
}

impl BloomFilterIndex {
    pub fn new() -> BloomFilterIndex {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bloomFilter",
            |m: &BloomFilterIndex| { &m.bloomFilter },
            |m: &mut BloomFilterIndex| { &mut m.bloomFilter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BloomFilterIndex>(
            "BloomFilterIndex",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BloomFilterIndex {
    const NAME: &'static str = "BloomFilterIndex";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bloomFilter.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.bloomFilter {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.bloomFilter {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BloomFilterIndex {
        BloomFilterIndex::new()
    }

    fn clear(&mut self) {
        self.bloomFilter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BloomFilterIndex {
        static instance: BloomFilterIndex = BloomFilterIndex {
            bloomFilter: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BloomFilterIndex {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BloomFilterIndex").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BloomFilterIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BloomFilterIndex {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.Stream)
pub struct Stream {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.Stream.kind)
    pub kind: ::std::option::Option<::protobuf::EnumOrUnknown<stream::Kind>>,
    // @@protoc_insertion_point(field:orc.proto.Stream.column)
    pub column: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:orc.proto.Stream.length)
    pub length: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.Stream.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Stream {
    fn default() -> &'a Stream {
        <Stream as ::protobuf::Message>::default_instance()
    }
}

impl Stream {
    pub fn new() -> Stream {
        ::std::default::Default::default()
    }

    // optional .orc.proto.Stream.Kind kind = 1;

    pub fn kind(&self) -> stream::Kind {
        match self.kind {
            Some(e) => e.enum_value_or(stream::Kind::PRESENT),
            None => stream::Kind::PRESENT,
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: stream::Kind) {
        self.kind = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 column = 2;

    pub fn column(&self) -> u32 {
        self.column.unwrap_or(0)
    }

    pub fn clear_column(&mut self) {
        self.column = ::std::option::Option::None;
    }

    pub fn has_column(&self) -> bool {
        self.column.is_some()
    }

    // Param is passed by value, moved
    pub fn set_column(&mut self, v: u32) {
        self.column = ::std::option::Option::Some(v);
    }

    // optional uint64 length = 3;

    pub fn length(&self) -> u64 {
        self.length.unwrap_or(0)
    }

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &Stream| { &m.kind },
            |m: &mut Stream| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "column",
            |m: &Stream| { &m.column },
            |m: &mut Stream| { &mut m.column },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "length",
            |m: &Stream| { &m.length },
            |m: &mut Stream| { &mut m.length },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stream>(
            "Stream",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Stream {
    const NAME: &'static str = "Stream";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.kind = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.column = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.length = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kind {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.column {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.kind {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.column {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.length {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Stream {
        Stream::new()
    }

    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.column = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Stream {
        static instance: Stream = Stream {
            kind: ::std::option::Option::None,
            column: ::std::option::Option::None,
            length: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Stream {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Stream").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Stream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Stream {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Stream`
pub mod stream {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:orc.proto.Stream.Kind)
    pub enum Kind {
        // @@protoc_insertion_point(enum_value:orc.proto.Stream.Kind.PRESENT)
        PRESENT = 0,
        // @@protoc_insertion_point(enum_value:orc.proto.Stream.Kind.DATA)
        DATA = 1,
        // @@protoc_insertion_point(enum_value:orc.proto.Stream.Kind.LENGTH)
        LENGTH = 2,
        // @@protoc_insertion_point(enum_value:orc.proto.Stream.Kind.DICTIONARY_DATA)
        DICTIONARY_DATA = 3,
        // @@protoc_insertion_point(enum_value:orc.proto.Stream.Kind.DICTIONARY_COUNT)
        DICTIONARY_COUNT = 4,
        // @@protoc_insertion_point(enum_value:orc.proto.Stream.Kind.SECONDARY)
        SECONDARY = 5,
        // @@protoc_insertion_point(enum_value:orc.proto.Stream.Kind.ROW_INDEX)
        ROW_INDEX = 6,
        // @@protoc_insertion_point(enum_value:orc.proto.Stream.Kind.BLOOM_FILTER)
        BLOOM_FILTER = 7,
        // @@protoc_insertion_point(enum_value:orc.proto.Stream.Kind.BLOOM_FILTER_UTF8)
        BLOOM_FILTER_UTF8 = 8,
        // @@protoc_insertion_point(enum_value:orc.proto.Stream.Kind.ENCRYPTED_INDEX)
        ENCRYPTED_INDEX = 9,
        // @@protoc_insertion_point(enum_value:orc.proto.Stream.Kind.ENCRYPTED_DATA)
        ENCRYPTED_DATA = 10,
        // @@protoc_insertion_point(enum_value:orc.proto.Stream.Kind.STRIPE_STATISTICS)
        STRIPE_STATISTICS = 100,
        // @@protoc_insertion_point(enum_value:orc.proto.Stream.Kind.FILE_STATISTICS)
        FILE_STATISTICS = 101,
    }

    impl ::protobuf::Enum for Kind {
        const NAME: &'static str = "Kind";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Kind> {
            match value {
                0 => ::std::option::Option::Some(Kind::PRESENT),
                1 => ::std::option::Option::Some(Kind::DATA),
                2 => ::std::option::Option::Some(Kind::LENGTH),
                3 => ::std::option::Option::Some(Kind::DICTIONARY_DATA),
                4 => ::std::option::Option::Some(Kind::DICTIONARY_COUNT),
                5 => ::std::option::Option::Some(Kind::SECONDARY),
                6 => ::std::option::Option::Some(Kind::ROW_INDEX),
                7 => ::std::option::Option::Some(Kind::BLOOM_FILTER),
                8 => ::std::option::Option::Some(Kind::BLOOM_FILTER_UTF8),
                9 => ::std::option::Option::Some(Kind::ENCRYPTED_INDEX),
                10 => ::std::option::Option::Some(Kind::ENCRYPTED_DATA),
                100 => ::std::option::Option::Some(Kind::STRIPE_STATISTICS),
                101 => ::std::option::Option::Some(Kind::FILE_STATISTICS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Kind] = &[
            Kind::PRESENT,
            Kind::DATA,
            Kind::LENGTH,
            Kind::DICTIONARY_DATA,
            Kind::DICTIONARY_COUNT,
            Kind::SECONDARY,
            Kind::ROW_INDEX,
            Kind::BLOOM_FILTER,
            Kind::BLOOM_FILTER_UTF8,
            Kind::ENCRYPTED_INDEX,
            Kind::ENCRYPTED_DATA,
            Kind::STRIPE_STATISTICS,
            Kind::FILE_STATISTICS,
        ];
    }

    impl ::protobuf::EnumFull for Kind {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Stream.Kind").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Kind::PRESENT => 0,
                Kind::DATA => 1,
                Kind::LENGTH => 2,
                Kind::DICTIONARY_DATA => 3,
                Kind::DICTIONARY_COUNT => 4,
                Kind::SECONDARY => 5,
                Kind::ROW_INDEX => 6,
                Kind::BLOOM_FILTER => 7,
                Kind::BLOOM_FILTER_UTF8 => 8,
                Kind::ENCRYPTED_INDEX => 9,
                Kind::ENCRYPTED_DATA => 10,
                Kind::STRIPE_STATISTICS => 11,
                Kind::FILE_STATISTICS => 12,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Kind {
        fn default() -> Self {
            Kind::PRESENT
        }
    }

    impl Kind {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Kind>("Stream.Kind")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.ColumnEncoding)
pub struct ColumnEncoding {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.ColumnEncoding.kind)
    pub kind: ::std::option::Option<::protobuf::EnumOrUnknown<column_encoding::Kind>>,
    // @@protoc_insertion_point(field:orc.proto.ColumnEncoding.dictionarySize)
    pub dictionarySize: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:orc.proto.ColumnEncoding.bloomEncoding)
    pub bloomEncoding: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.ColumnEncoding.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ColumnEncoding {
    fn default() -> &'a ColumnEncoding {
        <ColumnEncoding as ::protobuf::Message>::default_instance()
    }
}

impl ColumnEncoding {
    pub fn new() -> ColumnEncoding {
        ::std::default::Default::default()
    }

    // optional .orc.proto.ColumnEncoding.Kind kind = 1;

    pub fn kind(&self) -> column_encoding::Kind {
        match self.kind {
            Some(e) => e.enum_value_or(column_encoding::Kind::DIRECT),
            None => column_encoding::Kind::DIRECT,
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: column_encoding::Kind) {
        self.kind = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 dictionarySize = 2;

    pub fn dictionarySize(&self) -> u32 {
        self.dictionarySize.unwrap_or(0)
    }

    pub fn clear_dictionarySize(&mut self) {
        self.dictionarySize = ::std::option::Option::None;
    }

    pub fn has_dictionarySize(&self) -> bool {
        self.dictionarySize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dictionarySize(&mut self, v: u32) {
        self.dictionarySize = ::std::option::Option::Some(v);
    }

    // optional uint32 bloomEncoding = 3;

    pub fn bloomEncoding(&self) -> u32 {
        self.bloomEncoding.unwrap_or(0)
    }

    pub fn clear_bloomEncoding(&mut self) {
        self.bloomEncoding = ::std::option::Option::None;
    }

    pub fn has_bloomEncoding(&self) -> bool {
        self.bloomEncoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bloomEncoding(&mut self, v: u32) {
        self.bloomEncoding = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &ColumnEncoding| { &m.kind },
            |m: &mut ColumnEncoding| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dictionarySize",
            |m: &ColumnEncoding| { &m.dictionarySize },
            |m: &mut ColumnEncoding| { &mut m.dictionarySize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bloomEncoding",
            |m: &ColumnEncoding| { &m.bloomEncoding },
            |m: &mut ColumnEncoding| { &mut m.bloomEncoding },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColumnEncoding>(
            "ColumnEncoding",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ColumnEncoding {
    const NAME: &'static str = "ColumnEncoding";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.kind = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.dictionarySize = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bloomEncoding = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kind {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.dictionarySize {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bloomEncoding {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.kind {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.dictionarySize {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bloomEncoding {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ColumnEncoding {
        ColumnEncoding::new()
    }

    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.dictionarySize = ::std::option::Option::None;
        self.bloomEncoding = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ColumnEncoding {
        static instance: ColumnEncoding = ColumnEncoding {
            kind: ::std::option::Option::None,
            dictionarySize: ::std::option::Option::None,
            bloomEncoding: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ColumnEncoding {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ColumnEncoding").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ColumnEncoding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnEncoding {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ColumnEncoding`
pub mod column_encoding {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:orc.proto.ColumnEncoding.Kind)
    pub enum Kind {
        // @@protoc_insertion_point(enum_value:orc.proto.ColumnEncoding.Kind.DIRECT)
        DIRECT = 0,
        // @@protoc_insertion_point(enum_value:orc.proto.ColumnEncoding.Kind.DICTIONARY)
        DICTIONARY = 1,
        // @@protoc_insertion_point(enum_value:orc.proto.ColumnEncoding.Kind.DIRECT_V2)
        DIRECT_V2 = 2,
        // @@protoc_insertion_point(enum_value:orc.proto.ColumnEncoding.Kind.DICTIONARY_V2)
        DICTIONARY_V2 = 3,
    }

    impl ::protobuf::Enum for Kind {
        const NAME: &'static str = "Kind";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Kind> {
            match value {
                0 => ::std::option::Option::Some(Kind::DIRECT),
                1 => ::std::option::Option::Some(Kind::DICTIONARY),
                2 => ::std::option::Option::Some(Kind::DIRECT_V2),
                3 => ::std::option::Option::Some(Kind::DICTIONARY_V2),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Kind] = &[
            Kind::DIRECT,
            Kind::DICTIONARY,
            Kind::DIRECT_V2,
            Kind::DICTIONARY_V2,
        ];
    }

    impl ::protobuf::EnumFull for Kind {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ColumnEncoding.Kind").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Kind {
        fn default() -> Self {
            Kind::DIRECT
        }
    }

    impl Kind {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Kind>("ColumnEncoding.Kind")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.StripeEncryptionVariant)
pub struct StripeEncryptionVariant {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.StripeEncryptionVariant.streams)
    pub streams: ::std::vec::Vec<Stream>,
    // @@protoc_insertion_point(field:orc.proto.StripeEncryptionVariant.encoding)
    pub encoding: ::std::vec::Vec<ColumnEncoding>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.StripeEncryptionVariant.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StripeEncryptionVariant {
    fn default() -> &'a StripeEncryptionVariant {
        <StripeEncryptionVariant as ::protobuf::Message>::default_instance()
    }
}

impl StripeEncryptionVariant {
    pub fn new() -> StripeEncryptionVariant {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "streams",
            |m: &StripeEncryptionVariant| { &m.streams },
            |m: &mut StripeEncryptionVariant| { &mut m.streams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "encoding",
            |m: &StripeEncryptionVariant| { &m.encoding },
            |m: &mut StripeEncryptionVariant| { &mut m.encoding },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StripeEncryptionVariant>(
            "StripeEncryptionVariant",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StripeEncryptionVariant {
    const NAME: &'static str = "StripeEncryptionVariant";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.streams.push(is.read_message()?);
                },
                18 => {
                    self.encoding.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.streams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.encoding {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.streams {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.encoding {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StripeEncryptionVariant {
        StripeEncryptionVariant::new()
    }

    fn clear(&mut self) {
        self.streams.clear();
        self.encoding.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StripeEncryptionVariant {
        static instance: StripeEncryptionVariant = StripeEncryptionVariant {
            streams: ::std::vec::Vec::new(),
            encoding: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StripeEncryptionVariant {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StripeEncryptionVariant").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StripeEncryptionVariant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StripeEncryptionVariant {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.StripeFooter)
pub struct StripeFooter {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.StripeFooter.streams)
    pub streams: ::std::vec::Vec<Stream>,
    // @@protoc_insertion_point(field:orc.proto.StripeFooter.columns)
    pub columns: ::std::vec::Vec<ColumnEncoding>,
    // @@protoc_insertion_point(field:orc.proto.StripeFooter.writerTimezone)
    pub writerTimezone: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:orc.proto.StripeFooter.encryption)
    pub encryption: ::std::vec::Vec<StripeEncryptionVariant>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.StripeFooter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StripeFooter {
    fn default() -> &'a StripeFooter {
        <StripeFooter as ::protobuf::Message>::default_instance()
    }
}

impl StripeFooter {
    pub fn new() -> StripeFooter {
        ::std::default::Default::default()
    }

    // optional string writerTimezone = 3;

    pub fn writerTimezone(&self) -> &str {
        match self.writerTimezone.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_writerTimezone(&mut self) {
        self.writerTimezone = ::std::option::Option::None;
    }

    pub fn has_writerTimezone(&self) -> bool {
        self.writerTimezone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writerTimezone(&mut self, v: ::std::string::String) {
        self.writerTimezone = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_writerTimezone(&mut self) -> &mut ::std::string::String {
        if self.writerTimezone.is_none() {
            self.writerTimezone = ::std::option::Option::Some(::std::string::String::new());
        }
        self.writerTimezone.as_mut().unwrap()
    }

    // Take field
    pub fn take_writerTimezone(&mut self) -> ::std::string::String {
        self.writerTimezone.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "streams",
            |m: &StripeFooter| { &m.streams },
            |m: &mut StripeFooter| { &mut m.streams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "columns",
            |m: &StripeFooter| { &m.columns },
            |m: &mut StripeFooter| { &mut m.columns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "writerTimezone",
            |m: &StripeFooter| { &m.writerTimezone },
            |m: &mut StripeFooter| { &mut m.writerTimezone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "encryption",
            |m: &StripeFooter| { &m.encryption },
            |m: &mut StripeFooter| { &mut m.encryption },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StripeFooter>(
            "StripeFooter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StripeFooter {
    const NAME: &'static str = "StripeFooter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.streams.push(is.read_message()?);
                },
                18 => {
                    self.columns.push(is.read_message()?);
                },
                26 => {
                    self.writerTimezone = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.encryption.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.streams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.columns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.writerTimezone.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.encryption {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.streams {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.columns {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.writerTimezone.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.encryption {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StripeFooter {
        StripeFooter::new()
    }

    fn clear(&mut self) {
        self.streams.clear();
        self.columns.clear();
        self.writerTimezone = ::std::option::Option::None;
        self.encryption.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StripeFooter {
        static instance: StripeFooter = StripeFooter {
            streams: ::std::vec::Vec::new(),
            columns: ::std::vec::Vec::new(),
            writerTimezone: ::std::option::Option::None,
            encryption: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StripeFooter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StripeFooter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StripeFooter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StripeFooter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.StringPair)
pub struct StringPair {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.StringPair.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:orc.proto.StringPair.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.StringPair.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StringPair {
    fn default() -> &'a StringPair {
        <StringPair as ::protobuf::Message>::default_instance()
    }
}

impl StringPair {
    pub fn new() -> StringPair {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &StringPair| { &m.key },
            |m: &mut StringPair| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &StringPair| { &m.value },
            |m: &mut StringPair| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StringPair>(
            "StringPair",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StringPair {
    const NAME: &'static str = "StringPair";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StringPair {
        StringPair::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StringPair {
        static instance: StringPair = StringPair {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StringPair {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StringPair").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StringPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringPair {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.Type)
pub struct Type {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.Type.kind)
    pub kind: ::std::option::Option<::protobuf::EnumOrUnknown<type_::Kind>>,
    // @@protoc_insertion_point(field:orc.proto.Type.subtypes)
    pub subtypes: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:orc.proto.Type.fieldNames)
    pub fieldNames: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:orc.proto.Type.maximumLength)
    pub maximumLength: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:orc.proto.Type.precision)
    pub precision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:orc.proto.Type.scale)
    pub scale: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:orc.proto.Type.attributes)
    pub attributes: ::std::vec::Vec<StringPair>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.Type.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Type {
    fn default() -> &'a Type {
        <Type as ::protobuf::Message>::default_instance()
    }
}

impl Type {
    pub fn new() -> Type {
        ::std::default::Default::default()
    }

    // optional .orc.proto.Type.Kind kind = 1;

    pub fn kind(&self) -> type_::Kind {
        match self.kind {
            Some(e) => e.enum_value_or(type_::Kind::BOOLEAN),
            None => type_::Kind::BOOLEAN,
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: type_::Kind) {
        self.kind = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 maximumLength = 4;

    pub fn maximumLength(&self) -> u32 {
        self.maximumLength.unwrap_or(0)
    }

    pub fn clear_maximumLength(&mut self) {
        self.maximumLength = ::std::option::Option::None;
    }

    pub fn has_maximumLength(&self) -> bool {
        self.maximumLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximumLength(&mut self, v: u32) {
        self.maximumLength = ::std::option::Option::Some(v);
    }

    // optional uint32 precision = 5;

    pub fn precision(&self) -> u32 {
        self.precision.unwrap_or(0)
    }

    pub fn clear_precision(&mut self) {
        self.precision = ::std::option::Option::None;
    }

    pub fn has_precision(&self) -> bool {
        self.precision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_precision(&mut self, v: u32) {
        self.precision = ::std::option::Option::Some(v);
    }

    // optional uint32 scale = 6;

    pub fn scale(&self) -> u32 {
        self.scale.unwrap_or(0)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: u32) {
        self.scale = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &Type| { &m.kind },
            |m: &mut Type| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subtypes",
            |m: &Type| { &m.subtypes },
            |m: &mut Type| { &mut m.subtypes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fieldNames",
            |m: &Type| { &m.fieldNames },
            |m: &mut Type| { &mut m.fieldNames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximumLength",
            |m: &Type| { &m.maximumLength },
            |m: &mut Type| { &mut m.maximumLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "precision",
            |m: &Type| { &m.precision },
            |m: &mut Type| { &mut m.precision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &Type| { &m.scale },
            |m: &mut Type| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attributes",
            |m: &Type| { &m.attributes },
            |m: &mut Type| { &mut m.attributes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Type>(
            "Type",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Type {
    const NAME: &'static str = "Type";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.kind = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.subtypes)?;
                },
                16 => {
                    self.subtypes.push(is.read_uint32()?);
                },
                26 => {
                    self.fieldNames.push(is.read_string()?);
                },
                32 => {
                    self.maximumLength = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.precision = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scale = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.attributes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kind {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(2, &self.subtypes);
        for value in &self.fieldNames {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.maximumLength {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.precision {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.scale {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.kind {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_repeated_packed_uint32(2, &self.subtypes)?;
        for v in &self.fieldNames {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.maximumLength {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.precision {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scale {
            os.write_uint32(6, v)?;
        }
        for v in &self.attributes {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Type {
        Type::new()
    }

    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.subtypes.clear();
        self.fieldNames.clear();
        self.maximumLength = ::std::option::Option::None;
        self.precision = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.attributes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Type {
        static instance: Type = Type {
            kind: ::std::option::Option::None,
            subtypes: ::std::vec::Vec::new(),
            fieldNames: ::std::vec::Vec::new(),
            maximumLength: ::std::option::Option::None,
            precision: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            attributes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Type {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Type").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Type`
pub mod type_ {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:orc.proto.Type.Kind)
    pub enum Kind {
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.BOOLEAN)
        BOOLEAN = 0,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.BYTE)
        BYTE = 1,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.SHORT)
        SHORT = 2,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.INT)
        INT = 3,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.LONG)
        LONG = 4,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.FLOAT)
        FLOAT = 5,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.DOUBLE)
        DOUBLE = 6,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.STRING)
        STRING = 7,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.BINARY)
        BINARY = 8,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.TIMESTAMP)
        TIMESTAMP = 9,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.LIST)
        LIST = 10,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.MAP)
        MAP = 11,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.STRUCT)
        STRUCT = 12,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.UNION)
        UNION = 13,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.DECIMAL)
        DECIMAL = 14,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.DATE)
        DATE = 15,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.VARCHAR)
        VARCHAR = 16,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.CHAR)
        CHAR = 17,
        // @@protoc_insertion_point(enum_value:orc.proto.Type.Kind.TIMESTAMP_INSTANT)
        TIMESTAMP_INSTANT = 18,
    }

    impl ::protobuf::Enum for Kind {
        const NAME: &'static str = "Kind";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Kind> {
            match value {
                0 => ::std::option::Option::Some(Kind::BOOLEAN),
                1 => ::std::option::Option::Some(Kind::BYTE),
                2 => ::std::option::Option::Some(Kind::SHORT),
                3 => ::std::option::Option::Some(Kind::INT),
                4 => ::std::option::Option::Some(Kind::LONG),
                5 => ::std::option::Option::Some(Kind::FLOAT),
                6 => ::std::option::Option::Some(Kind::DOUBLE),
                7 => ::std::option::Option::Some(Kind::STRING),
                8 => ::std::option::Option::Some(Kind::BINARY),
                9 => ::std::option::Option::Some(Kind::TIMESTAMP),
                10 => ::std::option::Option::Some(Kind::LIST),
                11 => ::std::option::Option::Some(Kind::MAP),
                12 => ::std::option::Option::Some(Kind::STRUCT),
                13 => ::std::option::Option::Some(Kind::UNION),
                14 => ::std::option::Option::Some(Kind::DECIMAL),
                15 => ::std::option::Option::Some(Kind::DATE),
                16 => ::std::option::Option::Some(Kind::VARCHAR),
                17 => ::std::option::Option::Some(Kind::CHAR),
                18 => ::std::option::Option::Some(Kind::TIMESTAMP_INSTANT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Kind] = &[
            Kind::BOOLEAN,
            Kind::BYTE,
            Kind::SHORT,
            Kind::INT,
            Kind::LONG,
            Kind::FLOAT,
            Kind::DOUBLE,
            Kind::STRING,
            Kind::BINARY,
            Kind::TIMESTAMP,
            Kind::LIST,
            Kind::MAP,
            Kind::STRUCT,
            Kind::UNION,
            Kind::DECIMAL,
            Kind::DATE,
            Kind::VARCHAR,
            Kind::CHAR,
            Kind::TIMESTAMP_INSTANT,
        ];
    }

    impl ::protobuf::EnumFull for Kind {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Type.Kind").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Kind {
        fn default() -> Self {
            Kind::BOOLEAN
        }
    }

    impl Kind {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Kind>("Type.Kind")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.StripeInformation)
pub struct StripeInformation {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.StripeInformation.offset)
    pub offset: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.StripeInformation.indexLength)
    pub indexLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.StripeInformation.dataLength)
    pub dataLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.StripeInformation.footerLength)
    pub footerLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.StripeInformation.numberOfRows)
    pub numberOfRows: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.StripeInformation.encryptStripeId)
    pub encryptStripeId: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.StripeInformation.encryptedLocalKeys)
    pub encryptedLocalKeys: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.StripeInformation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StripeInformation {
    fn default() -> &'a StripeInformation {
        <StripeInformation as ::protobuf::Message>::default_instance()
    }
}

impl StripeInformation {
    pub fn new() -> StripeInformation {
        ::std::default::Default::default()
    }

    // optional uint64 offset = 1;

    pub fn offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint64 indexLength = 2;

    pub fn indexLength(&self) -> u64 {
        self.indexLength.unwrap_or(0)
    }

    pub fn clear_indexLength(&mut self) {
        self.indexLength = ::std::option::Option::None;
    }

    pub fn has_indexLength(&self) -> bool {
        self.indexLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_indexLength(&mut self, v: u64) {
        self.indexLength = ::std::option::Option::Some(v);
    }

    // optional uint64 dataLength = 3;

    pub fn dataLength(&self) -> u64 {
        self.dataLength.unwrap_or(0)
    }

    pub fn clear_dataLength(&mut self) {
        self.dataLength = ::std::option::Option::None;
    }

    pub fn has_dataLength(&self) -> bool {
        self.dataLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataLength(&mut self, v: u64) {
        self.dataLength = ::std::option::Option::Some(v);
    }

    // optional uint64 footerLength = 4;

    pub fn footerLength(&self) -> u64 {
        self.footerLength.unwrap_or(0)
    }

    pub fn clear_footerLength(&mut self) {
        self.footerLength = ::std::option::Option::None;
    }

    pub fn has_footerLength(&self) -> bool {
        self.footerLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_footerLength(&mut self, v: u64) {
        self.footerLength = ::std::option::Option::Some(v);
    }

    // optional uint64 numberOfRows = 5;

    pub fn numberOfRows(&self) -> u64 {
        self.numberOfRows.unwrap_or(0)
    }

    pub fn clear_numberOfRows(&mut self) {
        self.numberOfRows = ::std::option::Option::None;
    }

    pub fn has_numberOfRows(&self) -> bool {
        self.numberOfRows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberOfRows(&mut self, v: u64) {
        self.numberOfRows = ::std::option::Option::Some(v);
    }

    // optional uint64 encryptStripeId = 6;

    pub fn encryptStripeId(&self) -> u64 {
        self.encryptStripeId.unwrap_or(0)
    }

    pub fn clear_encryptStripeId(&mut self) {
        self.encryptStripeId = ::std::option::Option::None;
    }

    pub fn has_encryptStripeId(&self) -> bool {
        self.encryptStripeId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryptStripeId(&mut self, v: u64) {
        self.encryptStripeId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &StripeInformation| { &m.offset },
            |m: &mut StripeInformation| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "indexLength",
            |m: &StripeInformation| { &m.indexLength },
            |m: &mut StripeInformation| { &mut m.indexLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dataLength",
            |m: &StripeInformation| { &m.dataLength },
            |m: &mut StripeInformation| { &mut m.dataLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "footerLength",
            |m: &StripeInformation| { &m.footerLength },
            |m: &mut StripeInformation| { &mut m.footerLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberOfRows",
            |m: &StripeInformation| { &m.numberOfRows },
            |m: &mut StripeInformation| { &mut m.numberOfRows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encryptStripeId",
            |m: &StripeInformation| { &m.encryptStripeId },
            |m: &mut StripeInformation| { &mut m.encryptStripeId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "encryptedLocalKeys",
            |m: &StripeInformation| { &m.encryptedLocalKeys },
            |m: &mut StripeInformation| { &mut m.encryptedLocalKeys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StripeInformation>(
            "StripeInformation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StripeInformation {
    const NAME: &'static str = "StripeInformation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.offset = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.indexLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.dataLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.footerLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.numberOfRows = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.encryptStripeId = ::std::option::Option::Some(is.read_uint64()?);
                },
                58 => {
                    self.encryptedLocalKeys.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.indexLength {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.dataLength {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.footerLength {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.numberOfRows {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.encryptStripeId {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        for value in &self.encryptedLocalKeys {
            my_size += ::protobuf::rt::bytes_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.offset {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.indexLength {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.dataLength {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.footerLength {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.numberOfRows {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.encryptStripeId {
            os.write_uint64(6, v)?;
        }
        for v in &self.encryptedLocalKeys {
            os.write_bytes(7, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StripeInformation {
        StripeInformation::new()
    }

    fn clear(&mut self) {
        self.offset = ::std::option::Option::None;
        self.indexLength = ::std::option::Option::None;
        self.dataLength = ::std::option::Option::None;
        self.footerLength = ::std::option::Option::None;
        self.numberOfRows = ::std::option::Option::None;
        self.encryptStripeId = ::std::option::Option::None;
        self.encryptedLocalKeys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StripeInformation {
        static instance: StripeInformation = StripeInformation {
            offset: ::std::option::Option::None,
            indexLength: ::std::option::Option::None,
            dataLength: ::std::option::Option::None,
            footerLength: ::std::option::Option::None,
            numberOfRows: ::std::option::Option::None,
            encryptStripeId: ::std::option::Option::None,
            encryptedLocalKeys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StripeInformation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StripeInformation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StripeInformation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StripeInformation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.UserMetadataItem)
pub struct UserMetadataItem {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.UserMetadataItem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:orc.proto.UserMetadataItem.value)
    pub value: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.UserMetadataItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserMetadataItem {
    fn default() -> &'a UserMetadataItem {
        <UserMetadataItem as ::protobuf::Message>::default_instance()
    }
}

impl UserMetadataItem {
    pub fn new() -> UserMetadataItem {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes value = 2;

    pub fn value(&self) -> &[u8] {
        match self.value.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        self.value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &UserMetadataItem| { &m.name },
            |m: &mut UserMetadataItem| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &UserMetadataItem| { &m.value },
            |m: &mut UserMetadataItem| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserMetadataItem>(
            "UserMetadataItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserMetadataItem {
    const NAME: &'static str = "UserMetadataItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserMetadataItem {
        UserMetadataItem::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserMetadataItem {
        static instance: UserMetadataItem = UserMetadataItem {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserMetadataItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserMetadataItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserMetadataItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserMetadataItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.StripeStatistics)
pub struct StripeStatistics {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.StripeStatistics.colStats)
    pub colStats: ::std::vec::Vec<ColumnStatistics>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.StripeStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StripeStatistics {
    fn default() -> &'a StripeStatistics {
        <StripeStatistics as ::protobuf::Message>::default_instance()
    }
}

impl StripeStatistics {
    pub fn new() -> StripeStatistics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "colStats",
            |m: &StripeStatistics| { &m.colStats },
            |m: &mut StripeStatistics| { &mut m.colStats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StripeStatistics>(
            "StripeStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StripeStatistics {
    const NAME: &'static str = "StripeStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.colStats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.colStats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.colStats {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StripeStatistics {
        StripeStatistics::new()
    }

    fn clear(&mut self) {
        self.colStats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StripeStatistics {
        static instance: StripeStatistics = StripeStatistics {
            colStats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StripeStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StripeStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StripeStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StripeStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.Metadata)
pub struct Metadata {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.Metadata.stripeStats)
    pub stripeStats: ::std::vec::Vec<StripeStatistics>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.Metadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Metadata {
    fn default() -> &'a Metadata {
        <Metadata as ::protobuf::Message>::default_instance()
    }
}

impl Metadata {
    pub fn new() -> Metadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stripeStats",
            |m: &Metadata| { &m.stripeStats },
            |m: &mut Metadata| { &mut m.stripeStats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Metadata>(
            "Metadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Metadata {
    const NAME: &'static str = "Metadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stripeStats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stripeStats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.stripeStats {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Metadata {
        Metadata::new()
    }

    fn clear(&mut self) {
        self.stripeStats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Metadata {
        static instance: Metadata = Metadata {
            stripeStats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Metadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Metadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Metadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.ColumnarStripeStatistics)
pub struct ColumnarStripeStatistics {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.ColumnarStripeStatistics.colStats)
    pub colStats: ::std::vec::Vec<ColumnStatistics>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.ColumnarStripeStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ColumnarStripeStatistics {
    fn default() -> &'a ColumnarStripeStatistics {
        <ColumnarStripeStatistics as ::protobuf::Message>::default_instance()
    }
}

impl ColumnarStripeStatistics {
    pub fn new() -> ColumnarStripeStatistics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "colStats",
            |m: &ColumnarStripeStatistics| { &m.colStats },
            |m: &mut ColumnarStripeStatistics| { &mut m.colStats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColumnarStripeStatistics>(
            "ColumnarStripeStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ColumnarStripeStatistics {
    const NAME: &'static str = "ColumnarStripeStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.colStats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.colStats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.colStats {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ColumnarStripeStatistics {
        ColumnarStripeStatistics::new()
    }

    fn clear(&mut self) {
        self.colStats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ColumnarStripeStatistics {
        static instance: ColumnarStripeStatistics = ColumnarStripeStatistics {
            colStats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ColumnarStripeStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ColumnarStripeStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ColumnarStripeStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnarStripeStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.FileStatistics)
pub struct FileStatistics {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.FileStatistics.column)
    pub column: ::std::vec::Vec<ColumnStatistics>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.FileStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileStatistics {
    fn default() -> &'a FileStatistics {
        <FileStatistics as ::protobuf::Message>::default_instance()
    }
}

impl FileStatistics {
    pub fn new() -> FileStatistics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "column",
            |m: &FileStatistics| { &m.column },
            |m: &mut FileStatistics| { &mut m.column },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileStatistics>(
            "FileStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileStatistics {
    const NAME: &'static str = "FileStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.column.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.column {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.column {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileStatistics {
        FileStatistics::new()
    }

    fn clear(&mut self) {
        self.column.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileStatistics {
        static instance: FileStatistics = FileStatistics {
            column: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.DataMask)
pub struct DataMask {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.DataMask.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:orc.proto.DataMask.maskParameters)
    pub maskParameters: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:orc.proto.DataMask.columns)
    pub columns: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.DataMask.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DataMask {
    fn default() -> &'a DataMask {
        <DataMask as ::protobuf::Message>::default_instance()
    }
}

impl DataMask {
    pub fn new() -> DataMask {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &DataMask| { &m.name },
            |m: &mut DataMask| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "maskParameters",
            |m: &DataMask| { &m.maskParameters },
            |m: &mut DataMask| { &mut m.maskParameters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "columns",
            |m: &DataMask| { &m.columns },
            |m: &mut DataMask| { &mut m.columns },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataMask>(
            "DataMask",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DataMask {
    const NAME: &'static str = "DataMask";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.maskParameters.push(is.read_string()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.columns)?;
                },
                24 => {
                    self.columns.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.maskParameters {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.columns);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.maskParameters {
            os.write_string(2, &v)?;
        };
        os.write_repeated_packed_uint32(3, &self.columns)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DataMask {
        DataMask::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.maskParameters.clear();
        self.columns.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DataMask {
        static instance: DataMask = DataMask {
            name: ::std::option::Option::None,
            maskParameters: ::std::vec::Vec::new(),
            columns: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DataMask {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DataMask").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DataMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMask {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.EncryptionKey)
pub struct EncryptionKey {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.EncryptionKey.keyName)
    pub keyName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:orc.proto.EncryptionKey.keyVersion)
    pub keyVersion: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:orc.proto.EncryptionKey.algorithm)
    pub algorithm: ::std::option::Option<::protobuf::EnumOrUnknown<EncryptionAlgorithm>>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.EncryptionKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EncryptionKey {
    fn default() -> &'a EncryptionKey {
        <EncryptionKey as ::protobuf::Message>::default_instance()
    }
}

impl EncryptionKey {
    pub fn new() -> EncryptionKey {
        ::std::default::Default::default()
    }

    // optional string keyName = 1;

    pub fn keyName(&self) -> &str {
        match self.keyName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_keyName(&mut self) {
        self.keyName = ::std::option::Option::None;
    }

    pub fn has_keyName(&self) -> bool {
        self.keyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyName(&mut self, v: ::std::string::String) {
        self.keyName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyName(&mut self) -> &mut ::std::string::String {
        if self.keyName.is_none() {
            self.keyName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.keyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyName(&mut self) -> ::std::string::String {
        self.keyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 keyVersion = 2;

    pub fn keyVersion(&self) -> u32 {
        self.keyVersion.unwrap_or(0)
    }

    pub fn clear_keyVersion(&mut self) {
        self.keyVersion = ::std::option::Option::None;
    }

    pub fn has_keyVersion(&self) -> bool {
        self.keyVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyVersion(&mut self, v: u32) {
        self.keyVersion = ::std::option::Option::Some(v);
    }

    // optional .orc.proto.EncryptionAlgorithm algorithm = 3;

    pub fn algorithm(&self) -> EncryptionAlgorithm {
        match self.algorithm {
            Some(e) => e.enum_value_or(EncryptionAlgorithm::UNKNOWN_ENCRYPTION),
            None => EncryptionAlgorithm::UNKNOWN_ENCRYPTION,
        }
    }

    pub fn clear_algorithm(&mut self) {
        self.algorithm = ::std::option::Option::None;
    }

    pub fn has_algorithm(&self) -> bool {
        self.algorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: EncryptionAlgorithm) {
        self.algorithm = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyName",
            |m: &EncryptionKey| { &m.keyName },
            |m: &mut EncryptionKey| { &mut m.keyName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyVersion",
            |m: &EncryptionKey| { &m.keyVersion },
            |m: &mut EncryptionKey| { &mut m.keyVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "algorithm",
            |m: &EncryptionKey| { &m.algorithm },
            |m: &mut EncryptionKey| { &mut m.algorithm },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EncryptionKey>(
            "EncryptionKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EncryptionKey {
    const NAME: &'static str = "EncryptionKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keyName = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.keyVersion = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.algorithm = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.keyName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.keyVersion {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.algorithm {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.keyName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.keyVersion {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.algorithm {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EncryptionKey {
        EncryptionKey::new()
    }

    fn clear(&mut self) {
        self.keyName = ::std::option::Option::None;
        self.keyVersion = ::std::option::Option::None;
        self.algorithm = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EncryptionKey {
        static instance: EncryptionKey = EncryptionKey {
            keyName: ::std::option::Option::None,
            keyVersion: ::std::option::Option::None,
            algorithm: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EncryptionKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EncryptionKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EncryptionKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptionKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.EncryptionVariant)
pub struct EncryptionVariant {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.EncryptionVariant.root)
    pub root: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:orc.proto.EncryptionVariant.key)
    pub key: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:orc.proto.EncryptionVariant.encryptedKey)
    pub encryptedKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:orc.proto.EncryptionVariant.stripeStatistics)
    pub stripeStatistics: ::std::vec::Vec<Stream>,
    // @@protoc_insertion_point(field:orc.proto.EncryptionVariant.fileStatistics)
    pub fileStatistics: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.EncryptionVariant.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EncryptionVariant {
    fn default() -> &'a EncryptionVariant {
        <EncryptionVariant as ::protobuf::Message>::default_instance()
    }
}

impl EncryptionVariant {
    pub fn new() -> EncryptionVariant {
        ::std::default::Default::default()
    }

    // optional uint32 root = 1;

    pub fn root(&self) -> u32 {
        self.root.unwrap_or(0)
    }

    pub fn clear_root(&mut self) {
        self.root = ::std::option::Option::None;
    }

    pub fn has_root(&self) -> bool {
        self.root.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root(&mut self, v: u32) {
        self.root = ::std::option::Option::Some(v);
    }

    // optional uint32 key = 2;

    pub fn key(&self) -> u32 {
        self.key.unwrap_or(0)
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = ::std::option::Option::Some(v);
    }

    // optional bytes encryptedKey = 3;

    pub fn encryptedKey(&self) -> &[u8] {
        match self.encryptedKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encryptedKey(&mut self) {
        self.encryptedKey = ::std::option::Option::None;
    }

    pub fn has_encryptedKey(&self) -> bool {
        self.encryptedKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryptedKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.encryptedKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryptedKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encryptedKey.is_none() {
            self.encryptedKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encryptedKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryptedKey(&mut self) -> ::std::vec::Vec<u8> {
        self.encryptedKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fileStatistics = 5;

    pub fn fileStatistics(&self) -> &[u8] {
        match self.fileStatistics.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileStatistics(&mut self) {
        self.fileStatistics = ::std::option::Option::None;
    }

    pub fn has_fileStatistics(&self) -> bool {
        self.fileStatistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileStatistics(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileStatistics = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileStatistics(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileStatistics.is_none() {
            self.fileStatistics = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileStatistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileStatistics(&mut self) -> ::std::vec::Vec<u8> {
        self.fileStatistics.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "root",
            |m: &EncryptionVariant| { &m.root },
            |m: &mut EncryptionVariant| { &mut m.root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &EncryptionVariant| { &m.key },
            |m: &mut EncryptionVariant| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encryptedKey",
            |m: &EncryptionVariant| { &m.encryptedKey },
            |m: &mut EncryptionVariant| { &mut m.encryptedKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stripeStatistics",
            |m: &EncryptionVariant| { &m.stripeStatistics },
            |m: &mut EncryptionVariant| { &mut m.stripeStatistics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileStatistics",
            |m: &EncryptionVariant| { &m.fileStatistics },
            |m: &mut EncryptionVariant| { &mut m.fileStatistics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EncryptionVariant>(
            "EncryptionVariant",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EncryptionVariant {
    const NAME: &'static str = "EncryptionVariant";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.root = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.key = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.encryptedKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.stripeStatistics.push(is.read_message()?);
                },
                42 => {
                    self.fileStatistics = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.root {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.key {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.encryptedKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        for value in &self.stripeStatistics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.fileStatistics.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.root {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.key {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.encryptedKey.as_ref() {
            os.write_bytes(3, v)?;
        }
        for v in &self.stripeStatistics {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.fileStatistics.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EncryptionVariant {
        EncryptionVariant::new()
    }

    fn clear(&mut self) {
        self.root = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.encryptedKey = ::std::option::Option::None;
        self.stripeStatistics.clear();
        self.fileStatistics = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EncryptionVariant {
        static instance: EncryptionVariant = EncryptionVariant {
            root: ::std::option::Option::None,
            key: ::std::option::Option::None,
            encryptedKey: ::std::option::Option::None,
            stripeStatistics: ::std::vec::Vec::new(),
            fileStatistics: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EncryptionVariant {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EncryptionVariant").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EncryptionVariant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptionVariant {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.Encryption)
pub struct Encryption {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.Encryption.mask)
    pub mask: ::std::vec::Vec<DataMask>,
    // @@protoc_insertion_point(field:orc.proto.Encryption.key)
    pub key: ::std::vec::Vec<EncryptionKey>,
    // @@protoc_insertion_point(field:orc.proto.Encryption.variants)
    pub variants: ::std::vec::Vec<EncryptionVariant>,
    // @@protoc_insertion_point(field:orc.proto.Encryption.keyProvider)
    pub keyProvider: ::std::option::Option<::protobuf::EnumOrUnknown<KeyProviderKind>>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.Encryption.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Encryption {
    fn default() -> &'a Encryption {
        <Encryption as ::protobuf::Message>::default_instance()
    }
}

impl Encryption {
    pub fn new() -> Encryption {
        ::std::default::Default::default()
    }

    // optional .orc.proto.KeyProviderKind keyProvider = 4;

    pub fn keyProvider(&self) -> KeyProviderKind {
        match self.keyProvider {
            Some(e) => e.enum_value_or(KeyProviderKind::UNKNOWN),
            None => KeyProviderKind::UNKNOWN,
        }
    }

    pub fn clear_keyProvider(&mut self) {
        self.keyProvider = ::std::option::Option::None;
    }

    pub fn has_keyProvider(&self) -> bool {
        self.keyProvider.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyProvider(&mut self, v: KeyProviderKind) {
        self.keyProvider = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mask",
            |m: &Encryption| { &m.mask },
            |m: &mut Encryption| { &mut m.mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "key",
            |m: &Encryption| { &m.key },
            |m: &mut Encryption| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "variants",
            |m: &Encryption| { &m.variants },
            |m: &mut Encryption| { &mut m.variants },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyProvider",
            |m: &Encryption| { &m.keyProvider },
            |m: &mut Encryption| { &mut m.keyProvider },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Encryption>(
            "Encryption",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Encryption {
    const NAME: &'static str = "Encryption";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mask.push(is.read_message()?);
                },
                18 => {
                    self.key.push(is.read_message()?);
                },
                26 => {
                    self.variants.push(is.read_message()?);
                },
                32 => {
                    self.keyProvider = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.mask {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.key {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.variants {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.keyProvider {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.mask {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.key {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.variants {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.keyProvider {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Encryption {
        Encryption::new()
    }

    fn clear(&mut self) {
        self.mask.clear();
        self.key.clear();
        self.variants.clear();
        self.keyProvider = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Encryption {
        static instance: Encryption = Encryption {
            mask: ::std::vec::Vec::new(),
            key: ::std::vec::Vec::new(),
            variants: ::std::vec::Vec::new(),
            keyProvider: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Encryption {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Encryption").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Encryption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Encryption {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.Footer)
pub struct Footer {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.Footer.headerLength)
    pub headerLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.Footer.contentLength)
    pub contentLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.Footer.stripes)
    pub stripes: ::std::vec::Vec<StripeInformation>,
    // @@protoc_insertion_point(field:orc.proto.Footer.types)
    pub types: ::std::vec::Vec<Type>,
    // @@protoc_insertion_point(field:orc.proto.Footer.metadata)
    pub metadata: ::std::vec::Vec<UserMetadataItem>,
    // @@protoc_insertion_point(field:orc.proto.Footer.numberOfRows)
    pub numberOfRows: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.Footer.statistics)
    pub statistics: ::std::vec::Vec<ColumnStatistics>,
    // @@protoc_insertion_point(field:orc.proto.Footer.rowIndexStride)
    pub rowIndexStride: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:orc.proto.Footer.writer)
    pub writer: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:orc.proto.Footer.encryption)
    pub encryption: ::protobuf::MessageField<Encryption>,
    // @@protoc_insertion_point(field:orc.proto.Footer.calendar)
    pub calendar: ::std::option::Option<::protobuf::EnumOrUnknown<CalendarKind>>,
    // @@protoc_insertion_point(field:orc.proto.Footer.softwareVersion)
    pub softwareVersion: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.Footer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Footer {
    fn default() -> &'a Footer {
        <Footer as ::protobuf::Message>::default_instance()
    }
}

impl Footer {
    pub fn new() -> Footer {
        ::std::default::Default::default()
    }

    // optional uint64 headerLength = 1;

    pub fn headerLength(&self) -> u64 {
        self.headerLength.unwrap_or(0)
    }

    pub fn clear_headerLength(&mut self) {
        self.headerLength = ::std::option::Option::None;
    }

    pub fn has_headerLength(&self) -> bool {
        self.headerLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headerLength(&mut self, v: u64) {
        self.headerLength = ::std::option::Option::Some(v);
    }

    // optional uint64 contentLength = 2;

    pub fn contentLength(&self) -> u64 {
        self.contentLength.unwrap_or(0)
    }

    pub fn clear_contentLength(&mut self) {
        self.contentLength = ::std::option::Option::None;
    }

    pub fn has_contentLength(&self) -> bool {
        self.contentLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contentLength(&mut self, v: u64) {
        self.contentLength = ::std::option::Option::Some(v);
    }

    // optional uint64 numberOfRows = 6;

    pub fn numberOfRows(&self) -> u64 {
        self.numberOfRows.unwrap_or(0)
    }

    pub fn clear_numberOfRows(&mut self) {
        self.numberOfRows = ::std::option::Option::None;
    }

    pub fn has_numberOfRows(&self) -> bool {
        self.numberOfRows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberOfRows(&mut self, v: u64) {
        self.numberOfRows = ::std::option::Option::Some(v);
    }

    // optional uint32 rowIndexStride = 8;

    pub fn rowIndexStride(&self) -> u32 {
        self.rowIndexStride.unwrap_or(0)
    }

    pub fn clear_rowIndexStride(&mut self) {
        self.rowIndexStride = ::std::option::Option::None;
    }

    pub fn has_rowIndexStride(&self) -> bool {
        self.rowIndexStride.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rowIndexStride(&mut self, v: u32) {
        self.rowIndexStride = ::std::option::Option::Some(v);
    }

    // optional uint32 writer = 9;

    pub fn writer(&self) -> u32 {
        self.writer.unwrap_or(0)
    }

    pub fn clear_writer(&mut self) {
        self.writer = ::std::option::Option::None;
    }

    pub fn has_writer(&self) -> bool {
        self.writer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writer(&mut self, v: u32) {
        self.writer = ::std::option::Option::Some(v);
    }

    // optional .orc.proto.CalendarKind calendar = 11;

    pub fn calendar(&self) -> CalendarKind {
        match self.calendar {
            Some(e) => e.enum_value_or(CalendarKind::UNKNOWN_CALENDAR),
            None => CalendarKind::UNKNOWN_CALENDAR,
        }
    }

    pub fn clear_calendar(&mut self) {
        self.calendar = ::std::option::Option::None;
    }

    pub fn has_calendar(&self) -> bool {
        self.calendar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_calendar(&mut self, v: CalendarKind) {
        self.calendar = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string softwareVersion = 12;

    pub fn softwareVersion(&self) -> &str {
        match self.softwareVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_softwareVersion(&mut self) {
        self.softwareVersion = ::std::option::Option::None;
    }

    pub fn has_softwareVersion(&self) -> bool {
        self.softwareVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_softwareVersion(&mut self, v: ::std::string::String) {
        self.softwareVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_softwareVersion(&mut self) -> &mut ::std::string::String {
        if self.softwareVersion.is_none() {
            self.softwareVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.softwareVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_softwareVersion(&mut self) -> ::std::string::String {
        self.softwareVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "headerLength",
            |m: &Footer| { &m.headerLength },
            |m: &mut Footer| { &mut m.headerLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contentLength",
            |m: &Footer| { &m.contentLength },
            |m: &mut Footer| { &mut m.contentLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stripes",
            |m: &Footer| { &m.stripes },
            |m: &mut Footer| { &mut m.stripes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "types",
            |m: &Footer| { &m.types },
            |m: &mut Footer| { &mut m.types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metadata",
            |m: &Footer| { &m.metadata },
            |m: &mut Footer| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberOfRows",
            |m: &Footer| { &m.numberOfRows },
            |m: &mut Footer| { &mut m.numberOfRows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "statistics",
            |m: &Footer| { &m.statistics },
            |m: &mut Footer| { &mut m.statistics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rowIndexStride",
            |m: &Footer| { &m.rowIndexStride },
            |m: &mut Footer| { &mut m.rowIndexStride },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "writer",
            |m: &Footer| { &m.writer },
            |m: &mut Footer| { &mut m.writer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Encryption>(
            "encryption",
            |m: &Footer| { &m.encryption },
            |m: &mut Footer| { &mut m.encryption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "calendar",
            |m: &Footer| { &m.calendar },
            |m: &mut Footer| { &mut m.calendar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "softwareVersion",
            |m: &Footer| { &m.softwareVersion },
            |m: &mut Footer| { &mut m.softwareVersion },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Footer>(
            "Footer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Footer {
    const NAME: &'static str = "Footer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.headerLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.contentLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.stripes.push(is.read_message()?);
                },
                34 => {
                    self.types.push(is.read_message()?);
                },
                42 => {
                    self.metadata.push(is.read_message()?);
                },
                48 => {
                    self.numberOfRows = ::std::option::Option::Some(is.read_uint64()?);
                },
                58 => {
                    self.statistics.push(is.read_message()?);
                },
                64 => {
                    self.rowIndexStride = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.writer = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.encryption)?;
                },
                88 => {
                    self.calendar = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                98 => {
                    self.softwareVersion = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.headerLength {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.contentLength {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.stripes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.numberOfRows {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        for value in &self.statistics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.rowIndexStride {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.writer {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.encryption.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.calendar {
            my_size += ::protobuf::rt::int32_size(11, v.value());
        }
        if let Some(v) = self.softwareVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.headerLength {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.contentLength {
            os.write_uint64(2, v)?;
        }
        for v in &self.stripes {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.types {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.metadata {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.numberOfRows {
            os.write_uint64(6, v)?;
        }
        for v in &self.statistics {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.rowIndexStride {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.writer {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.encryption.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.calendar {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.softwareVersion.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Footer {
        Footer::new()
    }

    fn clear(&mut self) {
        self.headerLength = ::std::option::Option::None;
        self.contentLength = ::std::option::Option::None;
        self.stripes.clear();
        self.types.clear();
        self.metadata.clear();
        self.numberOfRows = ::std::option::Option::None;
        self.statistics.clear();
        self.rowIndexStride = ::std::option::Option::None;
        self.writer = ::std::option::Option::None;
        self.encryption.clear();
        self.calendar = ::std::option::Option::None;
        self.softwareVersion = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Footer {
        static instance: Footer = Footer {
            headerLength: ::std::option::Option::None,
            contentLength: ::std::option::Option::None,
            stripes: ::std::vec::Vec::new(),
            types: ::std::vec::Vec::new(),
            metadata: ::std::vec::Vec::new(),
            numberOfRows: ::std::option::Option::None,
            statistics: ::std::vec::Vec::new(),
            rowIndexStride: ::std::option::Option::None,
            writer: ::std::option::Option::None,
            encryption: ::protobuf::MessageField::none(),
            calendar: ::std::option::Option::None,
            softwareVersion: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Footer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Footer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Footer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Footer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.PostScript)
pub struct PostScript {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.PostScript.footerLength)
    pub footerLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.PostScript.compression)
    pub compression: ::std::option::Option<::protobuf::EnumOrUnknown<CompressionKind>>,
    // @@protoc_insertion_point(field:orc.proto.PostScript.compressionBlockSize)
    pub compressionBlockSize: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.PostScript.version)
    pub version: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:orc.proto.PostScript.metadataLength)
    pub metadataLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.PostScript.writerVersion)
    pub writerVersion: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:orc.proto.PostScript.stripeStatisticsLength)
    pub stripeStatisticsLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.PostScript.magic)
    pub magic: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.PostScript.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostScript {
    fn default() -> &'a PostScript {
        <PostScript as ::protobuf::Message>::default_instance()
    }
}

impl PostScript {
    pub fn new() -> PostScript {
        ::std::default::Default::default()
    }

    // optional uint64 footerLength = 1;

    pub fn footerLength(&self) -> u64 {
        self.footerLength.unwrap_or(0)
    }

    pub fn clear_footerLength(&mut self) {
        self.footerLength = ::std::option::Option::None;
    }

    pub fn has_footerLength(&self) -> bool {
        self.footerLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_footerLength(&mut self, v: u64) {
        self.footerLength = ::std::option::Option::Some(v);
    }

    // optional .orc.proto.CompressionKind compression = 2;

    pub fn compression(&self) -> CompressionKind {
        match self.compression {
            Some(e) => e.enum_value_or(CompressionKind::NONE),
            None => CompressionKind::NONE,
        }
    }

    pub fn clear_compression(&mut self) {
        self.compression = ::std::option::Option::None;
    }

    pub fn has_compression(&self) -> bool {
        self.compression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compression(&mut self, v: CompressionKind) {
        self.compression = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 compressionBlockSize = 3;

    pub fn compressionBlockSize(&self) -> u64 {
        self.compressionBlockSize.unwrap_or(0)
    }

    pub fn clear_compressionBlockSize(&mut self) {
        self.compressionBlockSize = ::std::option::Option::None;
    }

    pub fn has_compressionBlockSize(&self) -> bool {
        self.compressionBlockSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compressionBlockSize(&mut self, v: u64) {
        self.compressionBlockSize = ::std::option::Option::Some(v);
    }

    // optional uint64 metadataLength = 5;

    pub fn metadataLength(&self) -> u64 {
        self.metadataLength.unwrap_or(0)
    }

    pub fn clear_metadataLength(&mut self) {
        self.metadataLength = ::std::option::Option::None;
    }

    pub fn has_metadataLength(&self) -> bool {
        self.metadataLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadataLength(&mut self, v: u64) {
        self.metadataLength = ::std::option::Option::Some(v);
    }

    // optional uint32 writerVersion = 6;

    pub fn writerVersion(&self) -> u32 {
        self.writerVersion.unwrap_or(0)
    }

    pub fn clear_writerVersion(&mut self) {
        self.writerVersion = ::std::option::Option::None;
    }

    pub fn has_writerVersion(&self) -> bool {
        self.writerVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writerVersion(&mut self, v: u32) {
        self.writerVersion = ::std::option::Option::Some(v);
    }

    // optional uint64 stripeStatisticsLength = 7;

    pub fn stripeStatisticsLength(&self) -> u64 {
        self.stripeStatisticsLength.unwrap_or(0)
    }

    pub fn clear_stripeStatisticsLength(&mut self) {
        self.stripeStatisticsLength = ::std::option::Option::None;
    }

    pub fn has_stripeStatisticsLength(&self) -> bool {
        self.stripeStatisticsLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stripeStatisticsLength(&mut self, v: u64) {
        self.stripeStatisticsLength = ::std::option::Option::Some(v);
    }

    // optional string magic = 8000;

    pub fn magic(&self) -> &str {
        match self.magic.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_magic(&mut self) {
        self.magic = ::std::option::Option::None;
    }

    pub fn has_magic(&self) -> bool {
        self.magic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magic(&mut self, v: ::std::string::String) {
        self.magic = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_magic(&mut self) -> &mut ::std::string::String {
        if self.magic.is_none() {
            self.magic = ::std::option::Option::Some(::std::string::String::new());
        }
        self.magic.as_mut().unwrap()
    }

    // Take field
    pub fn take_magic(&mut self) -> ::std::string::String {
        self.magic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "footerLength",
            |m: &PostScript| { &m.footerLength },
            |m: &mut PostScript| { &mut m.footerLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "compression",
            |m: &PostScript| { &m.compression },
            |m: &mut PostScript| { &mut m.compression },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "compressionBlockSize",
            |m: &PostScript| { &m.compressionBlockSize },
            |m: &mut PostScript| { &mut m.compressionBlockSize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "version",
            |m: &PostScript| { &m.version },
            |m: &mut PostScript| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "metadataLength",
            |m: &PostScript| { &m.metadataLength },
            |m: &mut PostScript| { &mut m.metadataLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "writerVersion",
            |m: &PostScript| { &m.writerVersion },
            |m: &mut PostScript| { &mut m.writerVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stripeStatisticsLength",
            |m: &PostScript| { &m.stripeStatisticsLength },
            |m: &mut PostScript| { &mut m.stripeStatisticsLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "magic",
            |m: &PostScript| { &m.magic },
            |m: &mut PostScript| { &mut m.magic },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostScript>(
            "PostScript",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostScript {
    const NAME: &'static str = "PostScript";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.footerLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.compression = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.compressionBlockSize = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.version)?;
                },
                32 => {
                    self.version.push(is.read_uint32()?);
                },
                40 => {
                    self.metadataLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.writerVersion = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.stripeStatisticsLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                64002 => {
                    self.magic = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.footerLength {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.compression {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.compressionBlockSize {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(4, &self.version);
        if let Some(v) = self.metadataLength {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.writerVersion {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.stripeStatisticsLength {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.magic.as_ref() {
            my_size += ::protobuf::rt::string_size(8000, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.footerLength {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.compression {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.compressionBlockSize {
            os.write_uint64(3, v)?;
        }
        os.write_repeated_packed_uint32(4, &self.version)?;
        if let Some(v) = self.metadataLength {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.writerVersion {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.stripeStatisticsLength {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.magic.as_ref() {
            os.write_string(8000, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostScript {
        PostScript::new()
    }

    fn clear(&mut self) {
        self.footerLength = ::std::option::Option::None;
        self.compression = ::std::option::Option::None;
        self.compressionBlockSize = ::std::option::Option::None;
        self.version.clear();
        self.metadataLength = ::std::option::Option::None;
        self.writerVersion = ::std::option::Option::None;
        self.stripeStatisticsLength = ::std::option::Option::None;
        self.magic = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostScript {
        static instance: PostScript = PostScript {
            footerLength: ::std::option::Option::None,
            compression: ::std::option::Option::None,
            compressionBlockSize: ::std::option::Option::None,
            version: ::std::vec::Vec::new(),
            metadataLength: ::std::option::Option::None,
            writerVersion: ::std::option::Option::None,
            stripeStatisticsLength: ::std::option::Option::None,
            magic: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostScript {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostScript").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostScript {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostScript {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:orc.proto.FileTail)
pub struct FileTail {
    // message fields
    // @@protoc_insertion_point(field:orc.proto.FileTail.postscript)
    pub postscript: ::protobuf::MessageField<PostScript>,
    // @@protoc_insertion_point(field:orc.proto.FileTail.footer)
    pub footer: ::protobuf::MessageField<Footer>,
    // @@protoc_insertion_point(field:orc.proto.FileTail.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:orc.proto.FileTail.postscriptLength)
    pub postscriptLength: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:orc.proto.FileTail.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTail {
    fn default() -> &'a FileTail {
        <FileTail as ::protobuf::Message>::default_instance()
    }
}

impl FileTail {
    pub fn new() -> FileTail {
        ::std::default::Default::default()
    }

    // optional uint64 fileLength = 3;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional uint64 postscriptLength = 4;

    pub fn postscriptLength(&self) -> u64 {
        self.postscriptLength.unwrap_or(0)
    }

    pub fn clear_postscriptLength(&mut self) {
        self.postscriptLength = ::std::option::Option::None;
    }

    pub fn has_postscriptLength(&self) -> bool {
        self.postscriptLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postscriptLength(&mut self, v: u64) {
        self.postscriptLength = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PostScript>(
            "postscript",
            |m: &FileTail| { &m.postscript },
            |m: &mut FileTail| { &mut m.postscript },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Footer>(
            "footer",
            |m: &FileTail| { &m.footer },
            |m: &mut FileTail| { &mut m.footer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &FileTail| { &m.fileLength },
            |m: &mut FileTail| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "postscriptLength",
            |m: &FileTail| { &m.postscriptLength },
            |m: &mut FileTail| { &mut m.postscriptLength },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTail>(
            "FileTail",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTail {
    const NAME: &'static str = "FileTail";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.postscript)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.footer)?;
                },
                24 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.postscriptLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.postscript.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.footer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.postscriptLength {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.postscript.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.footer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.postscriptLength {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTail {
        FileTail::new()
    }

    fn clear(&mut self) {
        self.postscript.clear();
        self.footer.clear();
        self.fileLength = ::std::option::Option::None;
        self.postscriptLength = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTail {
        static instance: FileTail = FileTail {
            postscript: ::protobuf::MessageField::none(),
            footer: ::protobuf::MessageField::none(),
            fileLength: ::std::option::Option::None,
            postscriptLength: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTail {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTail").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTail {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:orc.proto.EncryptionAlgorithm)
pub enum EncryptionAlgorithm {
    // @@protoc_insertion_point(enum_value:orc.proto.EncryptionAlgorithm.UNKNOWN_ENCRYPTION)
    UNKNOWN_ENCRYPTION = 0,
    // @@protoc_insertion_point(enum_value:orc.proto.EncryptionAlgorithm.AES_CTR_128)
    AES_CTR_128 = 1,
    // @@protoc_insertion_point(enum_value:orc.proto.EncryptionAlgorithm.AES_CTR_256)
    AES_CTR_256 = 2,
}

impl ::protobuf::Enum for EncryptionAlgorithm {
    const NAME: &'static str = "EncryptionAlgorithm";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EncryptionAlgorithm> {
        match value {
            0 => ::std::option::Option::Some(EncryptionAlgorithm::UNKNOWN_ENCRYPTION),
            1 => ::std::option::Option::Some(EncryptionAlgorithm::AES_CTR_128),
            2 => ::std::option::Option::Some(EncryptionAlgorithm::AES_CTR_256),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EncryptionAlgorithm] = &[
        EncryptionAlgorithm::UNKNOWN_ENCRYPTION,
        EncryptionAlgorithm::AES_CTR_128,
        EncryptionAlgorithm::AES_CTR_256,
    ];
}

impl ::protobuf::EnumFull for EncryptionAlgorithm {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EncryptionAlgorithm").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EncryptionAlgorithm {
    fn default() -> Self {
        EncryptionAlgorithm::UNKNOWN_ENCRYPTION
    }
}

impl EncryptionAlgorithm {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EncryptionAlgorithm>("EncryptionAlgorithm")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:orc.proto.KeyProviderKind)
pub enum KeyProviderKind {
    // @@protoc_insertion_point(enum_value:orc.proto.KeyProviderKind.UNKNOWN)
    UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:orc.proto.KeyProviderKind.HADOOP)
    HADOOP = 1,
    // @@protoc_insertion_point(enum_value:orc.proto.KeyProviderKind.AWS)
    AWS = 2,
    // @@protoc_insertion_point(enum_value:orc.proto.KeyProviderKind.GCP)
    GCP = 3,
    // @@protoc_insertion_point(enum_value:orc.proto.KeyProviderKind.AZURE)
    AZURE = 4,
}

impl ::protobuf::Enum for KeyProviderKind {
    const NAME: &'static str = "KeyProviderKind";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KeyProviderKind> {
        match value {
            0 => ::std::option::Option::Some(KeyProviderKind::UNKNOWN),
            1 => ::std::option::Option::Some(KeyProviderKind::HADOOP),
            2 => ::std::option::Option::Some(KeyProviderKind::AWS),
            3 => ::std::option::Option::Some(KeyProviderKind::GCP),
            4 => ::std::option::Option::Some(KeyProviderKind::AZURE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [KeyProviderKind] = &[
        KeyProviderKind::UNKNOWN,
        KeyProviderKind::HADOOP,
        KeyProviderKind::AWS,
        KeyProviderKind::GCP,
        KeyProviderKind::AZURE,
    ];
}

impl ::protobuf::EnumFull for KeyProviderKind {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("KeyProviderKind").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for KeyProviderKind {
    fn default() -> Self {
        KeyProviderKind::UNKNOWN
    }
}

impl KeyProviderKind {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<KeyProviderKind>("KeyProviderKind")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:orc.proto.CalendarKind)
pub enum CalendarKind {
    // @@protoc_insertion_point(enum_value:orc.proto.CalendarKind.UNKNOWN_CALENDAR)
    UNKNOWN_CALENDAR = 0,
    // @@protoc_insertion_point(enum_value:orc.proto.CalendarKind.JULIAN_GREGORIAN)
    JULIAN_GREGORIAN = 1,
    // @@protoc_insertion_point(enum_value:orc.proto.CalendarKind.PROLEPTIC_GREGORIAN)
    PROLEPTIC_GREGORIAN = 2,
}

impl ::protobuf::Enum for CalendarKind {
    const NAME: &'static str = "CalendarKind";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CalendarKind> {
        match value {
            0 => ::std::option::Option::Some(CalendarKind::UNKNOWN_CALENDAR),
            1 => ::std::option::Option::Some(CalendarKind::JULIAN_GREGORIAN),
            2 => ::std::option::Option::Some(CalendarKind::PROLEPTIC_GREGORIAN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CalendarKind] = &[
        CalendarKind::UNKNOWN_CALENDAR,
        CalendarKind::JULIAN_GREGORIAN,
        CalendarKind::PROLEPTIC_GREGORIAN,
    ];
}

impl ::protobuf::EnumFull for CalendarKind {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CalendarKind").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CalendarKind {
    fn default() -> Self {
        CalendarKind::UNKNOWN_CALENDAR
    }
}

impl CalendarKind {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CalendarKind>("CalendarKind")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:orc.proto.CompressionKind)
pub enum CompressionKind {
    // @@protoc_insertion_point(enum_value:orc.proto.CompressionKind.NONE)
    NONE = 0,
    // @@protoc_insertion_point(enum_value:orc.proto.CompressionKind.ZLIB)
    ZLIB = 1,
    // @@protoc_insertion_point(enum_value:orc.proto.CompressionKind.SNAPPY)
    SNAPPY = 2,
    // @@protoc_insertion_point(enum_value:orc.proto.CompressionKind.LZO)
    LZO = 3,
    // @@protoc_insertion_point(enum_value:orc.proto.CompressionKind.LZ4)
    LZ4 = 4,
    // @@protoc_insertion_point(enum_value:orc.proto.CompressionKind.ZSTD)
    ZSTD = 5,
}

impl ::protobuf::Enum for CompressionKind {
    const NAME: &'static str = "CompressionKind";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CompressionKind> {
        match value {
            0 => ::std::option::Option::Some(CompressionKind::NONE),
            1 => ::std::option::Option::Some(CompressionKind::ZLIB),
            2 => ::std::option::Option::Some(CompressionKind::SNAPPY),
            3 => ::std::option::Option::Some(CompressionKind::LZO),
            4 => ::std::option::Option::Some(CompressionKind::LZ4),
            5 => ::std::option::Option::Some(CompressionKind::ZSTD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CompressionKind] = &[
        CompressionKind::NONE,
        CompressionKind::ZLIB,
        CompressionKind::SNAPPY,
        CompressionKind::LZO,
        CompressionKind::LZ4,
        CompressionKind::ZSTD,
    ];
}

impl ::protobuf::EnumFull for CompressionKind {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CompressionKind").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CompressionKind {
    fn default() -> Self {
        CompressionKind::NONE
    }
}

impl CompressionKind {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CompressionKind>("CompressionKind")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0forc_proto.proto\x12\torc.proto\"Y\n\x11IntegerStatistics\x12\x18\n\
    \x07minimum\x18\x01\x20\x01(\x12R\x07minimum\x12\x18\n\x07maximum\x18\
    \x02\x20\x01(\x12R\x07maximum\x12\x10\n\x03sum\x18\x03\x20\x01(\x12R\x03\
    sum\"X\n\x10DoubleStatistics\x12\x18\n\x07minimum\x18\x01\x20\x01(\x01R\
    \x07minimum\x12\x18\n\x07maximum\x18\x02\x20\x01(\x01R\x07maximum\x12\
    \x10\n\x03sum\x18\x03\x20\x01(\x01R\x03sum\"\x98\x01\n\x10StringStatisti\
    cs\x12\x18\n\x07minimum\x18\x01\x20\x01(\tR\x07minimum\x12\x18\n\x07maxi\
    mum\x18\x02\x20\x01(\tR\x07maximum\x12\x10\n\x03sum\x18\x03\x20\x01(\x12\
    R\x03sum\x12\x1e\n\nlowerBound\x18\x04\x20\x01(\tR\nlowerBound\x12\x1e\n\
    \nupperBound\x18\x05\x20\x01(\tR\nupperBound\",\n\x10BucketStatistics\
    \x12\x18\n\x05count\x18\x01\x20\x03(\x04R\x05countB\x02\x10\x01\"Y\n\x11\
    DecimalStatistics\x12\x18\n\x07minimum\x18\x01\x20\x01(\tR\x07minimum\
    \x12\x18\n\x07maximum\x18\x02\x20\x01(\tR\x07maximum\x12\x10\n\x03sum\
    \x18\x03\x20\x01(\tR\x03sum\"D\n\x0eDateStatistics\x12\x18\n\x07minimum\
    \x18\x01\x20\x01(\x11R\x07minimum\x12\x18\n\x07maximum\x18\x02\x20\x01(\
    \x11R\x07maximum\"\xd1\x01\n\x13TimestampStatistics\x12\x18\n\x07minimum\
    \x18\x01\x20\x01(\x12R\x07minimum\x12\x18\n\x07maximum\x18\x02\x20\x01(\
    \x12R\x07maximum\x12\x1e\n\nminimumUtc\x18\x03\x20\x01(\x12R\nminimumUtc\
    \x12\x1e\n\nmaximumUtc\x18\x04\x20\x01(\x12R\nmaximumUtc\x12\"\n\x0cmini\
    mumNanos\x18\x05\x20\x01(\x05R\x0cminimumNanos\x12\"\n\x0cmaximumNanos\
    \x18\x06\x20\x01(\x05R\x0cmaximumNanos\"$\n\x10BinaryStatistics\x12\x10\
    \n\x03sum\x18\x01\x20\x01(\x12R\x03sum\"\x80\x01\n\x14CollectionStatisti\
    cs\x12\x20\n\x0bminChildren\x18\x01\x20\x01(\x04R\x0bminChildren\x12\x20\
    \n\x0bmaxChildren\x18\x02\x20\x01(\x04R\x0bmaxChildren\x12$\n\rtotalChil\
    dren\x18\x03\x20\x01(\x04R\rtotalChildren\"\x94\x06\n\x10ColumnStatistic\
    s\x12&\n\x0enumberOfValues\x18\x01\x20\x01(\x04R\x0enumberOfValues\x12B\
    \n\rintStatistics\x18\x02\x20\x01(\x0b2\x1c.orc.proto.IntegerStatisticsR\
    \rintStatistics\x12G\n\x10doubleStatistics\x18\x03\x20\x01(\x0b2\x1b.orc\
    .proto.DoubleStatisticsR\x10doubleStatistics\x12G\n\x10stringStatistics\
    \x18\x04\x20\x01(\x0b2\x1b.orc.proto.StringStatisticsR\x10stringStatisti\
    cs\x12G\n\x10bucketStatistics\x18\x05\x20\x01(\x0b2\x1b.orc.proto.Bucket\
    StatisticsR\x10bucketStatistics\x12J\n\x11decimalStatistics\x18\x06\x20\
    \x01(\x0b2\x1c.orc.proto.DecimalStatisticsR\x11decimalStatistics\x12A\n\
    \x0edateStatistics\x18\x07\x20\x01(\x0b2\x19.orc.proto.DateStatisticsR\
    \x0edateStatistics\x12G\n\x10binaryStatistics\x18\x08\x20\x01(\x0b2\x1b.\
    orc.proto.BinaryStatisticsR\x10binaryStatistics\x12P\n\x13timestampStati\
    stics\x18\t\x20\x01(\x0b2\x1e.orc.proto.TimestampStatisticsR\x13timestam\
    pStatistics\x12\x18\n\x07hasNull\x18\n\x20\x01(\x08R\x07hasNull\x12\x20\
    \n\x0bbytesOnDisk\x18\x0b\x20\x01(\x04R\x0bbytesOnDisk\x12S\n\x14collect\
    ionStatistics\x18\x0c\x20\x01(\x0b2\x1f.orc.proto.CollectionStatisticsR\
    \x14collectionStatistics\"n\n\rRowIndexEntry\x12\x20\n\tpositions\x18\
    \x01\x20\x03(\x04R\tpositionsB\x02\x10\x01\x12;\n\nstatistics\x18\x02\
    \x20\x01(\x0b2\x1b.orc.proto.ColumnStatisticsR\nstatistics\":\n\x08RowIn\
    dex\x12.\n\x05entry\x18\x01\x20\x03(\x0b2\x18.orc.proto.RowIndexEntryR\
    \x05entry\"q\n\x0bBloomFilter\x12*\n\x10numHashFunctions\x18\x01\x20\x01\
    (\rR\x10numHashFunctions\x12\x16\n\x06bitset\x18\x02\x20\x03(\x06R\x06bi\
    tset\x12\x1e\n\nutf8bitset\x18\x03\x20\x01(\x0cR\nutf8bitset\"L\n\x10Blo\
    omFilterIndex\x128\n\x0bbloomFilter\x18\x01\x20\x03(\x0b2\x16.orc.proto.\
    BloomFilterR\x0bbloomFilter\"\xd7\x02\n\x06Stream\x12*\n\x04kind\x18\x01\
    \x20\x01(\x0e2\x16.orc.proto.Stream.KindR\x04kind\x12\x16\n\x06column\
    \x18\x02\x20\x01(\rR\x06column\x12\x16\n\x06length\x18\x03\x20\x01(\x04R\
    \x06length\"\xf0\x01\n\x04Kind\x12\x0b\n\x07PRESENT\x10\0\x12\x08\n\x04D\
    ATA\x10\x01\x12\n\n\x06LENGTH\x10\x02\x12\x13\n\x0fDICTIONARY_DATA\x10\
    \x03\x12\x14\n\x10DICTIONARY_COUNT\x10\x04\x12\r\n\tSECONDARY\x10\x05\
    \x12\r\n\tROW_INDEX\x10\x06\x12\x10\n\x0cBLOOM_FILTER\x10\x07\x12\x15\n\
    \x11BLOOM_FILTER_UTF8\x10\x08\x12\x13\n\x0fENCRYPTED_INDEX\x10\t\x12\x12\
    \n\x0eENCRYPTED_DATA\x10\n\x12\x15\n\x11STRIPE_STATISTICS\x10d\x12\x13\n\
    \x0fFILE_STATISTICS\x10e\"\xd8\x01\n\x0eColumnEncoding\x122\n\x04kind\
    \x18\x01\x20\x01(\x0e2\x1e.orc.proto.ColumnEncoding.KindR\x04kind\x12&\n\
    \x0edictionarySize\x18\x02\x20\x01(\rR\x0edictionarySize\x12$\n\rbloomEn\
    coding\x18\x03\x20\x01(\rR\rbloomEncoding\"D\n\x04Kind\x12\n\n\x06DIRECT\
    \x10\0\x12\x0e\n\nDICTIONARY\x10\x01\x12\r\n\tDIRECT_V2\x10\x02\x12\x11\
    \n\rDICTIONARY_V2\x10\x03\"}\n\x17StripeEncryptionVariant\x12+\n\x07stre\
    ams\x18\x01\x20\x03(\x0b2\x11.orc.proto.StreamR\x07streams\x125\n\x08enc\
    oding\x18\x02\x20\x03(\x0b2\x19.orc.proto.ColumnEncodingR\x08encoding\"\
    \xdc\x01\n\x0cStripeFooter\x12+\n\x07streams\x18\x01\x20\x03(\x0b2\x11.o\
    rc.proto.StreamR\x07streams\x123\n\x07columns\x18\x02\x20\x03(\x0b2\x19.\
    orc.proto.ColumnEncodingR\x07columns\x12&\n\x0ewriterTimezone\x18\x03\
    \x20\x01(\tR\x0ewriterTimezone\x12B\n\nencryption\x18\x04\x20\x03(\x0b2\
    \".orc.proto.StripeEncryptionVariantR\nencryption\"4\n\nStringPair\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value\"\xec\x03\n\x04Type\x12(\n\x04kind\x18\x01\x20\x01(\
    \x0e2\x14.orc.proto.Type.KindR\x04kind\x12\x1e\n\x08subtypes\x18\x02\x20\
    \x03(\rR\x08subtypesB\x02\x10\x01\x12\x1e\n\nfieldNames\x18\x03\x20\x03(\
    \tR\nfieldNames\x12$\n\rmaximumLength\x18\x04\x20\x01(\rR\rmaximumLength\
    \x12\x1c\n\tprecision\x18\x05\x20\x01(\rR\tprecision\x12\x14\n\x05scale\
    \x18\x06\x20\x01(\rR\x05scale\x125\n\nattributes\x18\x07\x20\x03(\x0b2\
    \x15.orc.proto.StringPairR\nattributes\"\xe8\x01\n\x04Kind\x12\x0b\n\x07\
    BOOLEAN\x10\0\x12\x08\n\x04BYTE\x10\x01\x12\t\n\x05SHORT\x10\x02\x12\x07\
    \n\x03INT\x10\x03\x12\x08\n\x04LONG\x10\x04\x12\t\n\x05FLOAT\x10\x05\x12\
    \n\n\x06DOUBLE\x10\x06\x12\n\n\x06STRING\x10\x07\x12\n\n\x06BINARY\x10\
    \x08\x12\r\n\tTIMESTAMP\x10\t\x12\x08\n\x04LIST\x10\n\x12\x07\n\x03MAP\
    \x10\x0b\x12\n\n\x06STRUCT\x10\x0c\x12\t\n\x05UNION\x10\r\x12\x0b\n\x07D\
    ECIMAL\x10\x0e\x12\x08\n\x04DATE\x10\x0f\x12\x0b\n\x07VARCHAR\x10\x10\
    \x12\x08\n\x04CHAR\x10\x11\x12\x15\n\x11TIMESTAMP_INSTANT\x10\x12\"\x8f\
    \x02\n\x11StripeInformation\x12\x16\n\x06offset\x18\x01\x20\x01(\x04R\
    \x06offset\x12\x20\n\x0bindexLength\x18\x02\x20\x01(\x04R\x0bindexLength\
    \x12\x1e\n\ndataLength\x18\x03\x20\x01(\x04R\ndataLength\x12\"\n\x0cfoot\
    erLength\x18\x04\x20\x01(\x04R\x0cfooterLength\x12\"\n\x0cnumberOfRows\
    \x18\x05\x20\x01(\x04R\x0cnumberOfRows\x12(\n\x0fencryptStripeId\x18\x06\
    \x20\x01(\x04R\x0fencryptStripeId\x12.\n\x12encryptedLocalKeys\x18\x07\
    \x20\x03(\x0cR\x12encryptedLocalKeys\"<\n\x10UserMetadataItem\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x0cR\x05value\"K\n\x10StripeStatistics\x127\n\x08colStats\x18\x01\x20\
    \x03(\x0b2\x1b.orc.proto.ColumnStatisticsR\x08colStats\"I\n\x08Metadata\
    \x12=\n\x0bstripeStats\x18\x01\x20\x03(\x0b2\x1b.orc.proto.StripeStatist\
    icsR\x0bstripeStats\"S\n\x18ColumnarStripeStatistics\x127\n\x08colStats\
    \x18\x01\x20\x03(\x0b2\x1b.orc.proto.ColumnStatisticsR\x08colStats\"E\n\
    \x0eFileStatistics\x123\n\x06column\x18\x01\x20\x03(\x0b2\x1b.orc.proto.\
    ColumnStatisticsR\x06column\"d\n\x08DataMask\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12&\n\x0emaskParameters\x18\x02\x20\x03(\tR\x0emas\
    kParameters\x12\x1c\n\x07columns\x18\x03\x20\x03(\rR\x07columnsB\x02\x10\
    \x01\"\x87\x01\n\rEncryptionKey\x12\x18\n\x07keyName\x18\x01\x20\x01(\tR\
    \x07keyName\x12\x1e\n\nkeyVersion\x18\x02\x20\x01(\rR\nkeyVersion\x12<\n\
    \talgorithm\x18\x03\x20\x01(\x0e2\x1e.orc.proto.EncryptionAlgorithmR\tal\
    gorithm\"\xc4\x01\n\x11EncryptionVariant\x12\x12\n\x04root\x18\x01\x20\
    \x01(\rR\x04root\x12\x10\n\x03key\x18\x02\x20\x01(\rR\x03key\x12\"\n\x0c\
    encryptedKey\x18\x03\x20\x01(\x0cR\x0cencryptedKey\x12=\n\x10stripeStati\
    stics\x18\x04\x20\x03(\x0b2\x11.orc.proto.StreamR\x10stripeStatistics\
    \x12&\n\x0efileStatistics\x18\x05\x20\x01(\x0cR\x0efileStatistics\"\xd9\
    \x01\n\nEncryption\x12'\n\x04mask\x18\x01\x20\x03(\x0b2\x13.orc.proto.Da\
    taMaskR\x04mask\x12*\n\x03key\x18\x02\x20\x03(\x0b2\x18.orc.proto.Encryp\
    tionKeyR\x03key\x128\n\x08variants\x18\x03\x20\x03(\x0b2\x1c.orc.proto.E\
    ncryptionVariantR\x08variants\x12<\n\x0bkeyProvider\x18\x04\x20\x01(\x0e\
    2\x1a.orc.proto.KeyProviderKindR\x0bkeyProvider\"\xa1\x04\n\x06Footer\
    \x12\"\n\x0cheaderLength\x18\x01\x20\x01(\x04R\x0cheaderLength\x12$\n\rc\
    ontentLength\x18\x02\x20\x01(\x04R\rcontentLength\x126\n\x07stripes\x18\
    \x03\x20\x03(\x0b2\x1c.orc.proto.StripeInformationR\x07stripes\x12%\n\
    \x05types\x18\x04\x20\x03(\x0b2\x0f.orc.proto.TypeR\x05types\x127\n\x08m\
    etadata\x18\x05\x20\x03(\x0b2\x1b.orc.proto.UserMetadataItemR\x08metadat\
    a\x12\"\n\x0cnumberOfRows\x18\x06\x20\x01(\x04R\x0cnumberOfRows\x12;\n\n\
    statistics\x18\x07\x20\x03(\x0b2\x1b.orc.proto.ColumnStatisticsR\nstatis\
    tics\x12&\n\x0erowIndexStride\x18\x08\x20\x01(\rR\x0erowIndexStride\x12\
    \x16\n\x06writer\x18\t\x20\x01(\rR\x06writer\x125\n\nencryption\x18\n\
    \x20\x01(\x0b2\x15.orc.proto.EncryptionR\nencryption\x123\n\x08calendar\
    \x18\x0b\x20\x01(\x0e2\x17.orc.proto.CalendarKindR\x08calendar\x12(\n\
    \x0fsoftwareVersion\x18\x0c\x20\x01(\tR\x0fsoftwareVersion\"\xdd\x02\n\n\
    PostScript\x12\"\n\x0cfooterLength\x18\x01\x20\x01(\x04R\x0cfooterLength\
    \x12<\n\x0bcompression\x18\x02\x20\x01(\x0e2\x1a.orc.proto.CompressionKi\
    ndR\x0bcompression\x122\n\x14compressionBlockSize\x18\x03\x20\x01(\x04R\
    \x14compressionBlockSize\x12\x1c\n\x07version\x18\x04\x20\x03(\rR\x07ver\
    sionB\x02\x10\x01\x12&\n\x0emetadataLength\x18\x05\x20\x01(\x04R\x0emeta\
    dataLength\x12$\n\rwriterVersion\x18\x06\x20\x01(\rR\rwriterVersion\x126\
    \n\x16stripeStatisticsLength\x18\x07\x20\x01(\x04R\x16stripeStatisticsLe\
    ngth\x12\x15\n\x05magic\x18\xc0>\x20\x01(\tR\x05magic\"\xb8\x01\n\x08Fil\
    eTail\x125\n\npostscript\x18\x01\x20\x01(\x0b2\x15.orc.proto.PostScriptR\
    \npostscript\x12)\n\x06footer\x18\x02\x20\x01(\x0b2\x11.orc.proto.Footer\
    R\x06footer\x12\x1e\n\nfileLength\x18\x03\x20\x01(\x04R\nfileLength\x12*\
    \n\x10postscriptLength\x18\x04\x20\x01(\x04R\x10postscriptLength*O\n\x13\
    EncryptionAlgorithm\x12\x16\n\x12UNKNOWN_ENCRYPTION\x10\0\x12\x0f\n\x0bA\
    ES_CTR_128\x10\x01\x12\x0f\n\x0bAES_CTR_256\x10\x02*G\n\x0fKeyProviderKi\
    nd\x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\x06HADOOP\x10\x01\x12\x07\n\x03AWS\
    \x10\x02\x12\x07\n\x03GCP\x10\x03\x12\t\n\x05AZURE\x10\x04*S\n\x0cCalend\
    arKind\x12\x14\n\x10UNKNOWN_CALENDAR\x10\0\x12\x14\n\x10JULIAN_GREGORIAN\
    \x10\x01\x12\x17\n\x13PROLEPTIC_GREGORIAN\x10\x02*M\n\x0fCompressionKind\
    \x12\x08\n\x04NONE\x10\0\x12\x08\n\x04ZLIB\x10\x01\x12\n\n\x06SNAPPY\x10\
    \x02\x12\x07\n\x03LZO\x10\x03\x12\x07\n\x03LZ4\x10\x04\x12\x08\n\x04ZSTD\
    \x10\x05B\x10\n\x0eorg.apache.orc\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(33);
            messages.push(IntegerStatistics::generated_message_descriptor_data());
            messages.push(DoubleStatistics::generated_message_descriptor_data());
            messages.push(StringStatistics::generated_message_descriptor_data());
            messages.push(BucketStatistics::generated_message_descriptor_data());
            messages.push(DecimalStatistics::generated_message_descriptor_data());
            messages.push(DateStatistics::generated_message_descriptor_data());
            messages.push(TimestampStatistics::generated_message_descriptor_data());
            messages.push(BinaryStatistics::generated_message_descriptor_data());
            messages.push(CollectionStatistics::generated_message_descriptor_data());
            messages.push(ColumnStatistics::generated_message_descriptor_data());
            messages.push(RowIndexEntry::generated_message_descriptor_data());
            messages.push(RowIndex::generated_message_descriptor_data());
            messages.push(BloomFilter::generated_message_descriptor_data());
            messages.push(BloomFilterIndex::generated_message_descriptor_data());
            messages.push(Stream::generated_message_descriptor_data());
            messages.push(ColumnEncoding::generated_message_descriptor_data());
            messages.push(StripeEncryptionVariant::generated_message_descriptor_data());
            messages.push(StripeFooter::generated_message_descriptor_data());
            messages.push(StringPair::generated_message_descriptor_data());
            messages.push(Type::generated_message_descriptor_data());
            messages.push(StripeInformation::generated_message_descriptor_data());
            messages.push(UserMetadataItem::generated_message_descriptor_data());
            messages.push(StripeStatistics::generated_message_descriptor_data());
            messages.push(Metadata::generated_message_descriptor_data());
            messages.push(ColumnarStripeStatistics::generated_message_descriptor_data());
            messages.push(FileStatistics::generated_message_descriptor_data());
            messages.push(DataMask::generated_message_descriptor_data());
            messages.push(EncryptionKey::generated_message_descriptor_data());
            messages.push(EncryptionVariant::generated_message_descriptor_data());
            messages.push(Encryption::generated_message_descriptor_data());
            messages.push(Footer::generated_message_descriptor_data());
            messages.push(PostScript::generated_message_descriptor_data());
            messages.push(FileTail::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(7);
            enums.push(EncryptionAlgorithm::generated_enum_descriptor_data());
            enums.push(KeyProviderKind::generated_enum_descriptor_data());
            enums.push(CalendarKind::generated_enum_descriptor_data());
            enums.push(CompressionKind::generated_enum_descriptor_data());
            enums.push(stream::Kind::generated_enum_descriptor_data());
            enums.push(column_encoding::Kind::generated_enum_descriptor_data());
            enums.push(type_::Kind::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
